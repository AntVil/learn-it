[
    {
        "id": 0,
        "folder": "Algorithmische Geometrie",
        "front": "Warum hat Sortieren durch Vergleiche die Zeitkomplexität Theta(n log n)?",
        "back": "Ein deterministischer Algorithmus wird für eine gegebene Folge immer die gleichen Schritte durchführen. Die Schritte können als ein Entscheidungsbaum (Ablaufplan) gesehen werden mit n! Blättern. Das liegt daran, dass es n! viele Verschiedene Folgen zu sortieren gibt. Die mindest-höhe (also Laufzeit) beträgt log2(n!) >= 1/3n log2(n). Da zB Heap-sort O(n log(n)) benötigt, hat Sortieren durch Vergleiche Theta(n log n).",
        "hint": "Entscheidungsbaum, Mindestlänge des längsten Wegs in einem binären Baum (log2(x))"
    },
    {
        "id": 1,
        "folder": "Algorithmische Geometrie",
        "front": "Erklären Sie das Prinzip der Reduktion, die Herleitung einer unteren Schranke für ein Problem aus einer unteren Schranke für ein anderes Problem.",
        "back": "Wenn jede Eingabe für ein Problem A transformiert werden kann auf die Eingabe eines unbekannten Problems B und die Ausgabe wieder zurück auf das eigentliche Problem A, dann ist das eine Problem A auf das andere reduzierbar. Die Transformationen dürfen dabei aber nicht eine höhere Komplexität haben, als die untere Schranke des bekannten Problems A. Die untere Schranke darf nicht im Widerspruch stehen, sonst wäre Problem A durch Transformation und Lösung von Problem B schneller zu lösen, was nicht sein kann.",
        "hint": ""
    },
    {
        "id": 2,
        "folder": "Algorithmische Geometrie",
        "front": "Auf welche untere Schranke stützt sich der Beweis, dass die Bestimmung des kleinsten Abstands zwischen n Punkten in der Ebene (dichtestes Paar) mindestens Omega(n log n) Zeit braucht?",
        "back": "Er stützt sich auf der Reduktion von epsilon-closeness (in Zahlenfolge) auf closest pair. Epsilon-closeness hat die Komplexität Omega(n log n). Die Transformationen von Zahlen auf Punkte und von dichtestem Paar auf ob ein Abstand kleiner epsilon ist, sind schneller lösbar. Also muss closest pair die untere Schranke Omega(n log n) haben, sonst wäre epsilon-closeness schneller lösbar, was nicht möglich ist.",
        "hint": "epsilon-closeness"
    },
    {
        "id": 3,
        "folder": "Algorithmische Geometrie",
        "front": "Wie lautet die Eulersche Formel für kreuzungsfreie geometrische Graphen in der Ebene? Beweis?",
        "back": "v - e + f = c + 1",
        "hint": "Knoten, Kanten, Flächen, Zusammenhangs-Komponenten"
    },
    {
        "id": 4,
        "folder": "Algorithmische Geometrie",
        "front": "Was ist das Charakteristische an allen Sweep-Verfahren? Wie heißen die Datenstrukturen, die dabei immer verwendet werden?",
        "back": "Ein Sweep-Verfahren verwandelt in einem statischen d-dimensionalen Problem eine dimension in eine zeitliche und läuft diese Dimension ab. (In der Ebene erfolgt dies meist mit der Sweep-Line.) Dabei wird eine Sweep-Status-Struktur mitgeführt, welche bei gewissen Ereignissen ggf. aktualisiert wird. Die Ereignisse liegen in einer Ereignis Struktur vor, die in manchen Fällen dynamisch ist.",
        "hint": ""
    },
    {
        "id": 5,
        "folder": "Algorithmische Geometrie",
        "front": "Wie kann man alle Schnittpunkte von n Liniensegmenten in der Ebene durch ein Sweep-Verfahren berechnen? Erklären Sie die Laufzeit von O((n+k)log n). Warum stimmt hier also O(n log n) nicht ganz?",
        "back": "Eine Sweep-line bewegt sich über die Ebene und speichert in der Sweep-Status-Struktur die Ordnung der geschnittenen Segmente. Die Ereignisse sind linker Endpunkt, rechter Endpunkt und Schnittpunkt. Die Laufzeit beträgt O((n+k)log n), weil die Berechnung proportional zur Anzahl der Schnittpunkte ist. Treten mehr Schnittpunkte auf müssen mehr Ereignisse von dem Sweep-Verfahren beachtet werden (dynamische Ereignis Struktur). Das Verfahren ist deswegen Output-Sensitiv.",
        "hint": ""
    },
    {
        "id": 6,
        "folder": "Algorithmische Geometrie",
        "front": "Wie würden Sie alle Schnittpunkte von n Geraden in der Ebene berechnen?",
        "back": "Ein Sweep-Verfahren anzuwenden wäre überflüssig, da jede Gerade sich sowieso mit jeder anderen Gerade schneidet. Es ist also möglich direkt alle Schnittpunkte zu berechnen. Die Output-Sensitivität des Sweep-Verfahren Hilft nicht.",
        "hint": "Je zwei Geraden schneiden sich, also k=Theta(n*n), lohnt sich da noch der Sweep?"
    },
    {
        "id": 7,
        "folder": "Algorithmische Geometrie",
        "front": "Erläutern Sie das Sweep-Verfahren für die Bestimmung des dichtesten Paars von n Punkten in der Ebene. Warum genügt es, ist es für die Laufzeit wichtig, dass man sich während des Sweeps nur die Punkte im vertikalen Streifen links von der sweep line merkt? Wie kann man das Verfahren auf höhere Dimensionen erweitern?",
        "back": "Es wird eine Sweep-line mit einem vertikalen Streifen dahinter verwendet. der Streifen hat dabei die Größe des bisher dichtesten Paars und speichert Punkte in einem balancierten Binärbaum. Er enthält also die einzig möglichen Kandidaten, welche einen geringeren Abstand haben können. Pro Ereignis müssen dabei nur maximal konstant viele (<= 6) Punkte betrachtet werden. Es kommt deswegen zur Laufzeit O(n log n). Bei höheren Dimensionen wie im Raum wird eine Datenstruktur benötigt, welche Bereichsabfragen in der Ebene in möglichst effizienter Zeit berechnen kann. Das Verfahren funktioniert dann Analog nur mit einem Quader statt Rechteck.",
        "hint": ""
    },
    {
        "id": 8,
        "folder": "Algorithmische Geometrie",
        "front": "Beschreiben Sie einen O(n log n)-Algorithmus zur Konstruktion der konvexen Hülle von n Punkten in der Ebene, und begründen Sie sein Laufzeitverhalten.",
        "back": "Die Konstruktion der konvexen Hülle mit dem Kontur-Verfahren erfolgt durch sortieren und erstellen des Kontur-Polygon von links und rechts. Danach kann in linearer Zeit die Konvexe Hülle aus der Kontur berechnet werden durch zurück-laufen auf dem Kontur-Polygon. Dabei ist es lineare Zeit, weil jeder Punkt der zurückgelaufen wird nie wieder besucht wird.",
        "hint": "Inkrementell, randomisiert, D & C, Kontur, ..."
    },
    {
        "id": 9,
        "folder": "Algorithmische Geometrie",
        "front": "Warum hat die Berechnung der konvexen Hülle von n Punkten in der Ebene die Zeitkomplexität Omega(n log n)? Beweis?",
        "back": "Sortieren kann auf konvexe Hülle reduziert werden. Die Punkte werden auf eine Parabel projiziert und danach wird die Hülle abgelaufen. Die Transformationen sind schneller als Omega(n log n). Berechnen der Konvexen Hülle kann nicht schneller als Omega(n log n) sein, da sonst Sortieren nicht die untere Schranke Omega(n log n) hätte, was ein Widerspruch wäre.",
        "hint": "Reduktion vom Sortierproblem, Punkte auf Parabel"
    },
    {
        "id": 10,
        "folder": "Algorithmische Geometrie",
        "front": "Wenn für eine Menge von n Punkten in der Ebene bereits bekannt ist, dass alle Punkte auf der konvexen Hülle liegen, kann dann die konvexe Hülle in linearer Zeit berechnet werden? Und was ist, wenn die Punkte bereits sortiert vorliegen?",
        "back": "Sind die Punkte sortiert, kann das Kontur-Polygon verfahren verwendet werden, welches sowohl die Kontur, als auch die Hülle daraus in linearer Zeit berechnet, bei einer bereits sortieren Punkte-Menge. Sind alle Punkte der Hülle bekannt ist es nicht möglich in linearer Zeit die Hülle zu bilden, da die Anordnung der Punkte nicht bekannt ist und die korrekte Anordnung nicht in linearer Zeit berechnet werden kann.",
        "hint": ""
    },
    {
        "id": 11,
        "folder": "Algorithmische Geometrie",
        "front": "Bestimmen Sie den Kern eines Beispielpolygons nach dem im Kurs angegebenen Verfahren. Wie viel Zeit benötigt das Verfahren?",
        "back": "Naiv den Schnitt aller Halbebenen, definiert durch die Kanten, zu berechnen benötigt O(n log n). Durch Berechnung der Wesentlichen Kantenfolgen erhält man zwei nach Winkeln sortierte Kantenfolgen und kann danach die Geraden zu deren dualen Punkten transformieren und daraus zwei Konvexe Hüllen berechnen. Der Schnitt dieser Hüllen entspricht dem Kern. Es ist zwar nötig zwei Kanten mit maximalem Drehwinkel zu bestimmen, aber das und alle anderen Schritte sind in O(n) möglich.",
        "hint": "Drehwinkelbedingung, F- und B-Kantenfolgen, Schnitt von unteren Halbebenen, konvexe Hülle von sortierten Punktmengen"
    },
    {
        "id": 12,
        "folder": "Algorithmische Geometrie",
        "front": "Wie viele Wächter benötigt man zur Bewachung eines konvexen, eines sternförmigen, eines beliebigen einfachen Polygons?",
        "back": "konvex / sternförmig: genau 1\nbeliebig einfach: max v / 3",
        "hint": "Toblerone-Polygon (Polygon mit Zacken getrennt durch horizontale Kanten)"
    },
    {
        "id": 13,
        "folder": "Algorithmische Geometrie",
        "front": "Mit wie vielen Wächtern kommt man bei einem einfachen Polygon immer aus und wo sollen sie platziert werden?",
        "back": "Es reichen immer v / 3 aus und sind manchmal sogar nötig. Durch Triangulation und 3-Färbung des Polygons kann eine der Farben gewählt werden (meist mit minialster Anzahl) und auf jeden Knoten mit dieser Farbe ein Wächter platziert werden.",
        "hint": "Triangulierung, 3-Färbung"
    },
    {
        "id": 14,
        "folder": "Algorithmische Geometrie",
        "front": "Zur 3-Färbung: was genau wird gefärbt, nach welcher Regel, warum ist dies immer möglich?",
        "back": "Die Konten einer Triangulation werden so gefärbt, dass benachbarte Knoten (Knoten die durch eine Kante verbunden sind) nicht die gleiche Farbe haben. Dies ist immer möglich, weil per Definition eine Triangulation eines einfachen Polygons nur aus Dreiecken besteht. Bei jedem Dreieck kommt dabei jede Farbe genau einmal vor. Das ist möglich, da die Triangulation einen Nachbarschafts Graph erzeugt in Form eines Baums.",
        "hint": ""
    },
    {
        "id": 15,
        "folder": "Algorithmische Geometrie",
        "front": "Erläutern Sie ein Verfahren zur Triangulierung eines einfachen Polygons.",
        "back": "Ein (y-)monotones Polygon kann in linearer Zeit trianguliert werden mit Hilfe eines Stapels. Dabei werden Schrittweise Dreiecke aus dem Polygon geschnitten. Einfache Polygone können in eine Menge von (y-)monotonen Polygone in Zeit O(n log n) umgewandelt werden. Dabei wird ein Sweep von oben und von unten durchgeführt um horizontale spitze Ecken zu beseitigen.",
        "hint": ""
    },
    {
        "id": 16,
        "folder": "Algorithmische Geometrie",
        "front": "Vergleichen Sie die geometrischen Datenstrukturen k-d-Baum und Bereichsbaum.",
        "back": "k-d-Baum split in unterschiedlichen Dimensionen bis einelementige Punkte-Mengen. Speicherbedarf linear, Bereichsabfragen in O(n^(1 - 1/k) + a) wenn balanciert. Bereichsbaum besteht aus einer Menge an balancierten Binär-Bäumen bei dem jeder Baum Bereiche einer Dimension Speichert, wobei Referenzen zu anderen Bäumen gespeichert werden. Wenn geringer Speicherbedarf wichtiger ist, dann sollte ein k-d-Baum einem Bereichsbaum vorgezogen werden, ansonsten wenn Laufzeit wichtiger ist, dann ist ein Bereichsbaum besser.",
        "hint": ""
    },
    {
        "id": 17,
        "folder": "Algorithmische Geometrie",
        "front": "Wie hoch ist der Aufwand einer Halbstreifenanfrage unter Verwendung eines Prioritäts-Suchbaumes? Beweis? Kann der Prioritäts-Suchbaum auch für rechteckige Anfragen nützlich sein?",
        "back": "Prioritäts-Suchbaum speichert Punkte in Binär-Baum, wobei y-Koordinaten stets steigen. Die Halbstreifenanfrage benötigt O(log n + a). Rechteckige Anfragen sind mit mehreren Bäumen möglich, wenn das Rechteck feste Höhe hat. Dabei werden Bereiche mit dieser Höhe gebildet, in denen jeweils eine Halbstreifenanfrage nach oben und unten möglich ist. Bei einer Anfrage werden die beiden geschnittenen Bereiche abgefragt und zusammengefügt.",
        "hint": ""
    },
    {
        "id": 18,
        "folder": "Algorithmische Geometrie",
        "front": "Zeichnen Sie das Voronoi-Diagramm zu vier oder fünf vorgegebenen Punkten",
        "back": "Unbegrenzte Regionen außen, Bi-Sektoren zwischen benachbarten Punkten, danach Sektoren verbinden.",
        "hint": "zur üblichen euklidischen Distanz, fangen Sie mit den Bi-Sektoren zwischen benachbarten Punkten an"
    },
    {
        "id": 19,
        "folder": "Algorithmische Geometrie",
        "front": "Beschreiben Sie einige Anwendungen von Voronoi-Diagrammen.",
        "back": "Berechnung der Delaunay Triangulation: Für die Punkte wird das Voronoi-Diagramm berechnet und anschließend der Duale-Graph bestimmt. Der Duale-Graph entspricht der Delaunay-Triangulation. Nächst gelegenen Punkt bestimmen für beliebigen Punkt. Jede Voronoi Region ist Konvex.",
        "hint": ""
    },
    {
        "id": 20,
        "folder": "Algorithmische Geometrie",
        "front": "Was ist die Delaunay-Triangulation? Wie und in welcher Zeit kann man die Delaunay-Triangulation in das Voronoi-Diagramm umrechnen?",
        "back": "Die Delaunay Triangulation ist der duale Graph des Voronoi Diagram. Sie ist eine Triangulation einer Punkte-Menge, bei dem die Umkreise von allen Dreiecken keine anderen Punkte enthalten. Eigenschaft ergibt sich aus Voronoi-Diagram, da Umkreise Voronoi-Knoten sind. Die Umwandlung von Voronoi zu Delaunay ist in beide Richtungen in linearer Zeit möglich.",
        "hint": "Dualität zwischen den beiden"
    },
    {
        "id": 21,
        "folder": "Algorithmische Geometrie",
        "front": "Beweisen Sie den Zusammenhang zwischen dem Voronoi-Diagramm und der konvexen Hülle der Punkte.",
        "back": "Für jede Kante der Konvexen-Hülle gilt, dass sie die Ebene in zwei Hälften unterteilt, wobei nur eine Hälfte alle Punkte enthält. Somit kann es keinen Punkt auf der anderen Halb-Ebenen geben. Aus diesem Grund ist die Voronoi-Kante, welche durch die Beiden Punkte der Kante der Konvexen-Hülle gebildet wird unbeschränkt. Genauso gilt, dass zu jedem Punkt auf der Hülle, die Normale zur Gerade durch den Punkt eine Halbgerade und somit unbeschränkt ist.",
        "hint": "Punkt auf konvexer Hülle <=> unbeschränkte Region"
    },
    {
        "id": 22,
        "folder": "Algorithmische Geometrie",
        "front": "Für welche Punktmengen hat das euklidische Voronoi-Diagramm die Struktur eines Baumes?",
        "back": "Alle Punkte, für die gilt, dass alle Punkte auf der Konvexen-Hülle liegen, haben die Eigenschaft, dass das Voronoi-Diagramm einen Baum bildet. Dass liegt daran, dass alle Voronoi-Regionen Unbeschränkt sein müssen, damit ein Baum entsteht und nur Knoten auf der Konvexen Hülle bilden Unbeschränkte Regionen.",
        "hint": ""
    },
    {
        "id": 23,
        "folder": "Algorithmische Geometrie",
        "front": "Zeichnen Sie zu zwei vorgegebenen Liniensegmenten den Bi-Sektor bezüglich der euklidischen Metrik, aus wie vielen Teilstücken kann der Bi-Sektor bestehen?",
        "back": "Bi-Sektor verläuft geradlinig außerhalb von Orthogonalen Bereichen und innerhalb beider Orthogonalen Bereiche (Winkelhalbierende). Ansonsten Verläuft er Parabel-Förmig. Der Bi-Sektor von zwei Liniensegmenten kann maximal aus 7 Teilstücken bestehen. (Bsp: '|-') Anwendung: zB durch Hindernisse schlüpfen.",
        "hint": ""
    },
    {
        "id": 27,
        "folder": "Algorithmische Geometrie",
        "front": "Beschreiben Sie das Verfahren geometrische Transformation zur Berechnung des Voronoi-Diagramms und skizzieren Sie die Laufzeitabschätzung.",
        "back": "Bei der geometrischen Transformation werden alle Punkte in der Ebene in den Raum projiziert mit Hilfe eines Paraboloid. (x, y) -> (x, y, x^2+y^2). Wegen der konvexen Eigenschaft des Paraboloid liegen alle Punkte auf der konvexen Hülle. Außerdem gilt die Umkreis-Eigenschaft, dass kein Punkt innerhalb des Umkreises eines Dreiecks ist, auf dem Paraboloid ebenfalls. Durch projizieren auf die Ebene erhält man die Delaunay-Triangulation und durch die Dualität auch das Voronoi-Diagramm. Schnitte mit der Tangential-Ebene von Dreiecken geben Ellipsen und zurück-transformiert wieder Kreise.",
        "hint": "Wie wird die Umkreis-Eigenschaft der Delaunay-Triangulation ausgenutzt, was hat dies mit der konvexen Hülle in drei Dimensionen zu tun?"
    },
    {
        "id": 28,
        "folder": "Algorithmische Geometrie",
        "front": "Was verstehen wir unter einem kompetitiven Verfahren, in welchen Zusammenhängen sind solche Verfahren interessant?",
        "back": "Verfahren, welche das Optimum meist nicht erreichen, aber nahe kommen und angewendet werden können bei NP-schweren Problemen bzw. Problemen mit unvollständigen Informationen. Kosten_Strategie(problem) <= KompetitiverFactor * kosten_optimum(problem) + Andere Für alle Probleme aus P",
        "hint": "NP-schwere Probleme und solche mit unvollständigen Informationen"
    },
    {
        "id": 29,
        "folder": "Algorithmische Geometrie",
        "front": "Beschreiben Sie das First-Fit-Verfahren für das Bin-Packing-Problem. Welcher kompetitive Faktor wird erreicht, warum?",
        "back": "Beim First-Fit-Verfahren wird immer in der gleichen Reihenfolge jeder Bin durchprobiert, bis ein passender gefunden ist. Der kompetitive Faktor liegt mindestens bei 2, weil maximal doppelt so viele Bins verwendet werden. Die Scharfe Schranke liegt sogar bei 1.7. Beweis für 2: Bin Packing macht höchstens einen Behälter nicht Halb-Voll. Optimum kann höchstens alle Behälter voll machen. First-Fit decreasing 1.22.",
        "hint": "anschaulich zu argumentieren ist hier einfacher als mit Formeln."
    },
    {
        "id": 30,
        "folder": "Algorithmische Geometrie",
        "front": "Wir suchen die Tür in der Wand. Welchen kompetitiven Faktor können wir erreichen, wie und warum? Kann es noch besser gehen?",
        "back": "Der optimale Kompetitive-Faktor liegt bei 9. Hierbei wird die Wand von beiden Seiten abwechselnd abgesucht. Die Such-Tiefe wird dabei nach jedem Richtungswechsel verdoppelt. Im schlimmsten Fall verfehlt man die Tür knapp und macht einen weiteren Durchlauf mehr. 2 * (1 + ... + 2^n + 2^n+1) + 2^n + epsilon = 2 * (2^(n+2) - 1) + 2^n + epsilon = 9 * 2^n + epsilon - 2",
        "hint": ""
    },
    {
        "id": 31,
        "folder": "Algorithmische Geometrie",
        "front": "Skizzieren Sie einen Algorithmus zum Verlassen eines Labyrinths.",
        "back": "Beim Pledge-Algorithmus wird Anfangs eine Richtung gewählt und ein Winkelzähler auf 0 gesetzt. Diese Richtung wird verfolgt, bis eine Wand im Weg ist. Der Wand wird im Uhrzeigersinn gefolgt und dabei wird der Winkelzähler aktualisiert. Sobald der Winkelzähler einen positiven Wert annehmen würde, wird die Wand verlassen und die Richtung wird weiterverfolgt. Dies wiederholt sich so lange, bis das Labyrinth verlassen wurde.",
        "hint": ""
    },
    {
        "id": 32,
        "folder": "Algorithmische Geometrie",
        "front": "Erläutern Sie das Suchverfahren der CAB-Strategie. Was sind selbst-nähernde Kurven? Was lässt sich über ihre Länge sagen?",
        "back": "Die CAB-Strategie ist eine Strategie den Kern eines Polygon zu bestimmen, wenn ein Roboter sich in einem Polygon befindet und dabei nur das Sichtbarkeitspolygon zur Verfügung hat. Auf dem Weg zum Kern vergrößert sich das Polygon, die CAB-Strategie nutzt dieses Phänomen. Hierzu folgt der Roboter den Winkelhalbierenden der wesentlichen Punkten. Die Wege die der Roboter dabei einschlägt sind selbst-nährend. Anschaulich bedeutet das, dass für drei aufeinanderfolgende Punkte a, b & c b näher an c liegt als a. Selbst-nähernde Kurven benötigen viel Platz um sich zu winden. Der Abstand zu den Endpunkten kann höchstens ~5.3331-mal so lang sein wie der direkte Weg.",
        "hint": ""
    },
    {
        "id": 33,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Zustand eines Objekts?",
        "back": "Die Menge aller Instanz-Variablen. Es sind alle bekannten Objekte, mit denen das Objekt in Beziehung steht.",
        "hint": ""
    },
    {
        "id": 34,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Pass/Call-by-Reference?",
        "back": "Es wird einer Funktion eine Referenz (Pointer) übergeben, welche auf den übergebenen Wert zeigt.",
        "hint": ""
    },
    {
        "id": 35,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Pass/Call-by-Value?",
        "back": "Es wird einer Funktion der momentane Wert übergeben.",
        "hint": ""
    },
    {
        "id": 36,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist ein Nachrichten-Selektor und wie ist er in SMALLTALK aufgebaut?",
        "back": "Ein Nachrichten-Selektor identifiziert eine Methode. Aufbau: '#parameter:parameter:'",
        "hint": ""
    },
    {
        "id": 37,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist ein Protokoll und ein Interface?",
        "back": "Das Interface gibt alle verstandenen Nachrichten an. Das Protokoll enthält den Nachrichten-Katalog und Kommentare.",
        "hint": ""
    },
    {
        "id": 38,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Nachrichten-Typen gibt es in SMALLTALK?",
        "back": "Unär (Nur implizites Argument), Binär (Spezielle Nachrichten wie '+') und Schlüsselwort (Nachrichten mit mehreren Argumenten)",
        "hint": ""
    },
    {
        "id": 39,
        "folder": "Objekt Orientierte Programmierung",
        "front": "In welcher Beziehung stehen Instanz, Klasse, Meta-Klasse?",
        "back": "Eine Instanz ist Objekt, dass von einer Klasse erzeugt wurde. Da Klassen auch Objekte sind (zumindest in SMALLTALK) haben Klassen auch Klasse, nämlich eine Meta-Klasse.",
        "hint": ""
    },
    {
        "id": 40,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist die Extension und Intension einer Klasse?",
        "back": "Extension ist die Menge aller Objekte die zu der Klasse gehören. Intension sind die Bedingungen die benötigt werden um zur Klasse zu gehören.",
        "hint": ""
    },
    {
        "id": 41,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist ein Literal und welche gibt es in SMALLTALK?",
        "back": "Ein Literal ist ein Objekt, dass während der Übersetzungszeit erzeugt wird. Es gibt Zahlen-, String-, Symbol- und Array-Literale.",
        "hint": ""
    },
    {
        "id": 42,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Aliase?",
        "back": "Aliase sind Variablen/Namen die auf das gleiche Objekt zeigen. Sie werden durch Zuweisungen (:=) erzeugt und zeigen somit auf die gleiche Speicheradresse.",
        "hint": ""
    },
    {
        "id": 43,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Garbage Collection? Warum ist es wichtig für OOP?",
        "back": "Garbage Collection deallokiert Speicher von Objekten die nicht mehr verwendet werden zu einem unbestimmten Zeitpunkt. Es ist wichtig, da Objekte an vielen verschiedenen erzeugt und 'entfernt' werden. (Es werden nur Aliase gelöscht)",
        "hint": ""
    },
    {
        "id": 44,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Instanz- und was Klassen-Variablen?",
        "back": "Instanz-Variablen gehören der Instanz und Klassen-Variablen der Klasse. Wird die Klasse als Instanz einer Meta-Klasse betrachtet werden dessen Variablen auch Instanz-Variablen genannt. Instanz-Variablen können nur von der Instanz gelesen und verändert werden.",
        "hint": ""
    },
    {
        "id": 45,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind pseudo-variablen in SMALLTALK?",
        "back": "Pseudo-Variablen sind Variablen die nur gelesen werden können und ersetzen Schlüsselwörter anderer Sprachen. (Bsp: 'true', 'false', 'nil', ...)",
        "hint": ""
    },
    {
        "id": 46,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Beziehungen in OOP? Was haben Zwischen-Objekte damit zu tun?",
        "back": "Beziehungen in OOP geben an welche Objekte sich kennen. Es gibt 1-Beziehungen und n-Beziehungen. Für n-Beziehungen werden meist Zwischen-Objekte benötigt, welche die Beziehung pflegen. Zwischen-Objekte sind meistens Collections.",
        "hint": ""
    },
    {
        "id": 47,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Vorteile von Kapselung?",
        "back": "Nur das Objekt selbst kann den eigenen Zustand ändern. Implementation von Methoden kann jederzeit angepasst werden ohne mehrere Klassen anpassen zu müssen.",
        "hint": ""
    },
    {
        "id": 48,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was versteht man unter Kaskadieren von Ausdrücken in SMALLTALK?",
        "back": "Da Ausdrücke immer Objekte liefern, können diesen erneut Nachrichten geschickt werden. Das Ergebnis eines Ausdrucks wird somit im nächsten Ausdruckt direkt verwendet. Falls ein Ausdruck keinen Rückgabewert mit '^' angibt, wird implizit das momentane Objekt zurückgeliefert.",
        "hint": "Chaining"
    },
    {
        "id": 49,
        "folder": "Objekt Orientierte Programmierung",
        "front": "In welcher Reihenfolge werden Ausdrücke in SMALLTALK ausgeführt? Was ist ein Problem hierbei?",
        "back": "Klammer Ausdrücke zuerst, danach von links nach rechts. Die Regel Punkt-vor-Strich gilt deshalb nicht und kann zu unerwarteten Ergebnissen führen.",
        "hint": ""
    },
    {
        "id": 50,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was versteht man unter dynamisches Binden? Was ist der Unterschied zum statischen Binden?",
        "back": "Beim dynamischen Binden wird zur Laufzeit des Programms entschieden, welche Methode aufgerufen wird. Es ist bedeutend für die Polymorphie. Beim statischen Binden werden Methoden bereits zur Übersetzungs-Zeit ausgewählt",
        "hint": ""
    },
    {
        "id": 51,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Varianten von Instanz-Variablen gibt es? Worin unterscheiden sie sich?",
        "back": "Es gibt benannte und indizierte Instanz Variablen. Benannte werden über einen Namen zugegriffen und indizierte über einen Index (beginnt in SMALLTALK bei 1)",
        "hint": ""
    },
    {
        "id": 52,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Nutzen von Konstanten-Methoden?",
        "back": "Konstante Methoden liefern einen Konstanten wert. Auf diese Weise kann der Wert nicht verändert werden.",
        "hint": "Bsp: pi"
    },
    {
        "id": 53,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wofür werden Blöcke in SMALLTALK verwendet?",
        "back": "Blöcke sind anonyme Funktions-Objekte (Closures), welche die bei der Erzeugung vorhandenen Variablen einfangen. Sie werden in SMALLTALK zusammen mit dem dynamischen Binden verwendet um Kontrollstrukturen zu bilden.",
        "hint": ""
    },
    {
        "id": 54,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was unterscheidet eine Direkte von einer Indirekten Instanz einer Klasse?",
        "back": "Eine Instanz ist direkte Instanz genau einer Klasse und indirekte Instanz aller Generalisierungen dieser Klasse.",
        "hint": ""
    },
    {
        "id": 55,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was gibt die Klassendefinition an?",
        "back": "Sie gibt die Intension der Klasse an und damit die benötigten Eigenschaften die Objekte brauchen um zu dieser Klasse zu gehören.",
        "hint": ""
    },
    {
        "id": 56,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist ein Konstruktor und was macht ihn besonders?",
        "back": "Ein Konstruktor ist eine Methode einer Klasse und erzeugt ein Objekt dieser Klasse. In vielen Sprachen hat der Konstruktor die Möglichkeit auf die Felder des zu erzeugenden Objekts zuzugreifen. In SMALLTALK muss dazu jedoch eine Methode auf dem neuen Objekt aufgerufen werden, da selbst Klassen nicht auf die Felder von ihren Objekten zugreifen können.",
        "hint": ""
    },
    {
        "id": 57,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was unterscheidet Klassifikation, Generalisierung und Spezialisierung?",
        "back": "Klassifikation sagt aus, dass ein Objekt genau zu einer Klasse gehört. Generalisierung ist eine Verallgemeinerung von einer Klasse und Spezialisierung das Gegenteil. Klassifikation ist, anders als Generalisierung, nicht transitiv. (Instanz einer Klasse kann nicht Instanz der Meta-Klasse sein)",
        "hint": ""
    },
    {
        "id": 58,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Zusammenhang zwischen Spezialisierung/Generalisierung und Vererbung?",
        "back": "Generalisierung/Spezialisierung sind theoretische Ansätze. Vererbung ist primär für die Wiederverwendung von Code gedacht. Ist die Vererbung keine Generalisierung/Spezialisierung, so kommt es schnell/häufig zu Problemen. (Pinguin ist nicht ein spezieller Vogel, da er nicht fliegen kann)",
        "hint": ""
    },
    {
        "id": 59,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Worin unterscheiden sich Überschreiben und Überladen?",
        "back": "Überschreiben ändern das Verhalten einer geerbten Methode ab. Überladen gibt mehrere mögliche Methode mit gleichem Namen an, welche ja nach Parameter-Typ aufgerufen werden.",
        "hint": ""
    },
    {
        "id": 60,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind abstrakte Klassen?",
        "back": "Eine abstrakte Klasse kann keine Instanzen erzeugen, da dessen Definition unvollständig ist. Das Gegenstück zu abstrakten Klassen sind konkrete Klassen.",
        "hint": ""
    },
    {
        "id": 61,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was versteht man unter offene Rekursion?",
        "back": "Bei offener Rekursion ruft eine Methode die in einer Eltern-Klasse definiert wurde auf dem gleichen Objekt eine Methode auf, welche in der Kind-Klasse definiert wird. Hierfür wird dynamisches Binden benötigt.",
        "hint": ""
    },
    {
        "id": 62,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Double-Dispatch und wann wird es benötigt?",
        "back": "Beim Double-Dispatch wird in einer Methode mit vertauschtem Empfänger aufgerufen, damit die korrekte Implementation ausgeführt wird. (Bsp: Operation zwischen 'int' und 'float') In typisierten Sprachen ist Double-Dispatch meist nicht nötig, da die korrekte Implementation durch Überladung aufgerufen wird.",
        "hint": ""
    },
    {
        "id": 63,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Vorteil von Delegation?",
        "back": "Bei Delegation verwendet ein Objekt ein anderes Objekt. Zum Beispiel kann ein Stack eine Liste verwenden. Hierbei besteht keine Vererbung und ein Stack besitzt nicht alle Methoden der Liste.",
        "hint": ""
    },
    {
        "id": 64,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist ein Typ und wofür werden Typ-systeme verwendet?",
        "back": "Ein Typ ist ein Name mit einem zugehörigen Protokoll. Es gibt alle verstandenen Nachrichten an. Typsysteme sollen verhindern, dass Objekte Nachrichten erhalten, die sie nicht verstehen.",
        "hint": ""
    },
    {
        "id": 65,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wann ist ein Programm typ-korrekt?",
        "back": "Für die Typ-Korrektheit müssen alle Zuweisungen im Programm überprüft werden. Falls keine Typ-Invariante verletzt wurde ist das Programm typ-korrekt. Typ-Invarianten geben an, welche Werte ein Typ annehmen kann.",
        "hint": ""
    },
    {
        "id": 66,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wann werden statische und wann dynamische Typ-Prüfungen durchgeführt?",
        "back": "Statische Typ-Prüfungen werden zur Übersetzungs-Zeit durchgeführt. Dynamische zur Laufzeit. Dynamische Prüfungen sind nötig, wenn zu einem Zeitpunkt nicht bekannt ist, mit welchem Typ man arbeitet.",
        "hint": ""
    },
    {
        "id": 67,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Unterschied zwischen Definition und Deklaration?",
        "back": "Deklaration gibt einem Bezeichner einen Typ. Definition gibt eine Speicherstelle (und manchmal auch Wert).",
        "hint": ""
    },
    {
        "id": 68,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Collections?",
        "back": "Collections sind Klassen/Objekte, welche n-Beziehungen pflegen. Sie speichern somit meist beliebig viele Objekte und geben verschiedene Arten Objekte hinzuzufügen, zu entfernen und zuzugreifen. (Bsp: List, Stack, Bag, ...)",
        "hint": ""
    },
    {
        "id": 69,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Arten gibt es Objekte zu erzeugen?",
        "back": "Objekte können über Literale, Abändern von bestehenden Objekten (Prototyp-Ansatz), Konstruktoren und Instanziierung von Klassen erzeugt werden.",
        "hint": ""
    },
    {
        "id": 70,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Warum ist es in den meisten (typisierten) Sprachen nicht möglich Methoden/Eigenschaften in Sub-Typen zu löschen?",
        "back": "Sub-Typen sollten als solche alle Nachrichten verstehen die deren Super-Typ versteht. Ansonsten könnte vom Typ-System nicht garantiert werden, dass jede Methode auf einem Typ stets Aufgerufen werden kann.",
        "hint": ""
    },
    {
        "id": 71,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Warum ist die Klassen-Hierarchie in SMALLTALK keine Generalisierungs-Hierarchie",
        "back": "Weil manche Collection Subklassen Methoden löschen.",
        "hint": ""
    },
    {
        "id": 72,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Vorteile hat ein Typ-System?",
        "back": "Weniger Laufzeitfehler, bessere Optimierungen, bessere Speichernutzung (weniger bedeutend wegen Referenz-Semantik), bessere Lesbarkeit",
        "hint": ""
    },
    {
        "id": 73,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Nachteile hat ein Typ-system?",
        "back": "Mehr Schreibarbeit, Laufzeitfehler weiterhin möglich (casting / Division mit 0)",
        "hint": ""
    },
    {
        "id": 74,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind nominale und strukturelle Zuweisungs-Kompatibilität und Typ-Äquivalenz?",
        "back": "Nominal bezieht sich auf den Namen und strukturell nur auf die Struktur. Typ-Äquivalenz bedeutet, dass zwei Typen gleich sind. Zuweisungs-Kompatibilität verlangt, dass zwei Typen gleich oder zumindest der eine Sub-Typ vom anderen ist.",
        "hint": ""
    },
    {
        "id": 75,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Kovarianz und Kontravarianz?",
        "back": "Kovarianz bedeutet, dass ein Sub-Typ in einer Überschriebenen Methoden auch einen Sub-Typ zurück liefert. Kontravarianz bedeutet, dass ein Sub-Typ in einer Überschriebenen Methode einen Super-Typ annimmt.",
        "hint": ""
    },
    {
        "id": 76,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Arten von Polymorphie gibt es?",
        "back": "Inklusions-Polymorphie (Subtyp-Polymorphie), einfache, rekursiv und rekursiv beschränkte Parametrische-Polymorphie (Generische-Typen)",
        "hint": ""
    },
    {
        "id": 77,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Warum sind in Java Sub-Typen Beziehungen von Klassen in Arrays von diesen Klassen ebenfalls Sub-Typen? Worin besteht das Problem?",
        "back": "Auf ein Array von Sub-Typen kann man lesend genau gleich zugreifen. Schreibend ist dies jedoch nur beschränkt möglich weswegen dynamische Typprüfungen durch Java durchgeführt werden, welche zu einem Laufzeitfehler führen. Bei der Parametrische-Polymorphie wurde diese Lücke im Typ-System nicht wiederholt.",
        "hint": ""
    },
    {
        "id": 78,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Weshalb ist Java nicht streng genommen rein Objekt-Orientiert?",
        "back": "Java hat Primitive-Datentypen ('int', 'boolean', ...) die keine Objekte sind.",
        "hint": ""
    },
    {
        "id": 79,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Besonderheit haben Konstruktoren in Java?",
        "back": "Konstruktoren sind zwischen Klassen- und Instanz-Methoden.",
        "hint": ""
    },
    {
        "id": 80,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welchen Nutzen hat das Schlüsselwort 'final' in Java?",
        "back": "Das Schlüsselwort 'final' kann verwendet werden um Vererbung von Klassen und Überschreiben von Methoden zu verhindern.",
        "hint": ""
    },
    {
        "id": 81,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie und warum kann Überladen in Java schief gehen?",
        "back": "Java schränkt zur Übersetzungszeit die Anzahl an passenden Methoden ein. Wenn bei einem Methodenaufruf mehrere Methoden passen und Java nicht entscheiden kann welche Methode aufgerufen werden soll, erhält man den Compiler-Fehler 'ambiguous'.",
        "hint": ""
    },
    {
        "id": 82,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Verwendet Java Call-by-Reference oder Call-by-Value?",
        "back": "Java verwendet Call-by-Value.",
        "hint": ""
    },
    {
        "id": 83,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie kann Code in Java strukturiert werden?",
        "back": "Java erlaubt es Code in Klassen und Inneren-Klassen, Paketen (Namespaces) und Modulen (Packet-Sammlung) zu strukturieren. Mit 'public', 'private' und 'protected' und Modulen können Sichtbarkeiten/Schnittstellen festgelegt werden.",
        "hint": ""
    },
    {
        "id": 84,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Java unterstützt zwar keine mehrfach-Vererbung, aber wie kann etwas ähnliches emuliert werden?",
        "back": "Java erlaubt es mehrere Interfaces in einer Klasse zu Implementieren. Durch 'default' können Interfaces sogar Implementation gegeben werden.",
        "hint": ""
    },
    {
        "id": 85,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wofür können Interfaces (in Java) verwendet werden?",
        "back": "Interfaces können verwendet werden um Implementations-Details zu verstecken oder um Schnittstellen zu definieren. Interfaces können auch zum Gruppieren/Tagging verwendet werden.",
        "hint": ""
    },
    {
        "id": 86,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wofür kann eine Liste vom Typ 'List<? extends A>' verwendet werden?",
        "back": "Die Liste enthält nur Sub-Typen von A. Es kann nur Lesend zugegriffen werden.",
        "hint": ""
    },
    {
        "id": 87,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wofür kann eine Liste vom Typ 'List<? super A>' verwendet werden?",
        "back": "Die Liste enthält nur Super-Typen von A. Es kann nur Schreibend zugegriffen werden.",
        "hint": ""
    },
    {
        "id": 88,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist das Wild-Card in Java und wofür gibt es das?",
        "back": "Wild-Cards werden mit '?' als Typ-Variable angegeben. 'List<?>' bezeichnet eine Liste mit beliebigen Elementen. Wild-Cards existieren um Typ-Sicher mit Parametrischer Polymorphie zu arbeiten.",
        "hint": ""
    },
    {
        "id": 89,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wieso ist es nicht möglich in einer Überschriebenen Methode neue Fehler einzuführen?",
        "back": "Einführen von neuen Fehlern wäre kovariantes Überschreiben von Methoden was in Sprachen wie Java nicht erlaubt ist.",
        "hint": ""
    },
    {
        "id": 90,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Ist in C# Call-by-Reference oder Call-by-Value?",
        "back": "Standardmäßig verwendet C# Call-by-Value. Mit 'unsafe' können Pointer ('int*') bzw mit 'ref' Referenzen verwendet werden. Pointer erlauben Modifikationen (Pointer-Arithmetik) und Referenzen erlauben nur lesenden Zugriff.",
        "hint": ""
    },
    {
        "id": 91,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind C# Properties?",
        "back": "C# Properties sind Wrapper um Attribute die implizit getter und setter verwenden. Auf diese Weise kann Bsp read-only Zugriff auf ein Attribut ermöglicht werden.",
        "hint": ""
    },
    {
        "id": 92,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie werden Indizierte Instanz-Variablen in C# implementiert?",
        "back": "In C# gibt es hierfür Indexer. Diese verhalten sich wie C# Properties.",
        "hint": ""
    },
    {
        "id": 93,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Typen haben Wert-Semantik in C#?",
        "back": "enum, struct, int, float, ...",
        "hint": ""
    },
    {
        "id": 94,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Lösung hat C# für das Fragile-Base-Class-Problem?",
        "back": "Methoden in C# können erst überschrieben werden, wenn sowohl in der Eltern-Klasse die Methode mit 'virtual' und in der Kind-Klasse mit 'override' angegeben wird. Dies verhindert, dass Methoden aus Versehen überschrieben oder nicht überschrieben werden.",
        "hint": ""
    },
    {
        "id": 95,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Unterschied zwischen dem Methoden-Modifier 'override' und 'new'",
        "back": "Bei 'override' wird immer die Kind-Klassen Implementation ausgeführt. Bei 'new' wird vom Kontext abhängig eine andere Methode aufgerufen.",
        "hint": ""
    },
    {
        "id": 96,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Unterstützt C# beschränkte parametrische Polymorphie?",
        "back": "Ja, mit 'Class C<T> where T : U'",
        "hint": ""
    },
    {
        "id": 97,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie werden Objekte in C++ erzeugt?",
        "back": "Es muss eine Klasse angelegt werden. Diese Klasse erzeugt zunächst jedoch 'struct'/'records's; also Werte. Erst wenn ein Pointer auf das struct erzeugt wird, kann man tatsächlich von einem Objekt mit Identität sprechen. 'A* a = new A();'",
        "hint": ""
    },
    {
        "id": 98,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Auto boxing?",
        "back": "Auto boxing macht aus einem Wert-Typen einen Referenz-Typen. (int -> Integer)",
        "hint": ""
    },
    {
        "id": 99,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Verwendet C++ Call-by-Value oder Call-by-Reference?",
        "back": "C++ verwendet standardmäßig Call-by-Value (Pointer werden kopiert). Für Call-by-Reference schreibt man 'void f(A** a)' oder 'void f(A* &a)'",
        "hint": ""
    },
    {
        "id": 100,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie können in C++ stark zusammenhängende Klassen auf Attribute voneinander zugreifen?",
        "back": "Die ist möglich durch 'friend class A', was der Klasse A erlaubt auf private Attribute zuzugreifen.",
        "hint": ""
    },
    {
        "id": 101,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Auswirkung hat die mehrfach-vererbung in C++?",
        "back": "Aufrufe von dynamisches-binden wird komplizierter zum Nachvollziehen.",
        "hint": ""
    },
    {
        "id": 102,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie werden Methoden in Java, C# und C++ gebunden?",
        "back": "Java: dynamisch\nC# & C++: statisch (dynamisch durch 'virtual')",
        "hint": ""
    },
    {
        "id": 103,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Worin unterscheiden sich Java und C++ hinsichtlich Klassen mit Typ-Parameter?",
        "back": "Java Generics erzeugen genau eine Klasse.\nC++ Templates erzeugen für jeden Belegung des Typ-Parameter eine Klasse.",
        "hint": "Generics (Java) vs Templates (C++)"
    },
    {
        "id": 104,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie kann das Typ-System in C++ umgangen werden?",
        "back": "Über Casts in C++. Diese sind jedoch gefährlich. Es sollte die Funktion 'dynamic_cast<T>' vorgezogen werden.",
        "hint": ""
    },
    {
        "id": 105,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Gibt es Zugriffs-Modifier in Eiffel?",
        "back": "In Eiffel sind alle Instanz-Variablen nur vom Objekt selbst zugreifbar, es braucht deswegen keine. Methoden können zu bestimmten Mengen an Klassen exportiert werden. (Darf auch leere Menge sein)",
        "hint": ""
    },
    {
        "id": 106,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie funktioniert Überladung und Überschreiben in Eiffel?",
        "back": "Überladen geht in Eiffel nicht, nur Überschreiben. zwei Methoden können gemeinsam in einer Klasse stehen, indem diese über ein rename umbenannt werden. Über den Typ der Klasse hat die Methode noch den gleichen Namen.",
        "hint": ""
    },
    {
        "id": 107,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind wichtige Eigenschaften von Eiffels Typsystem?",
        "back": "Mehrfachvererbung, Generizität, Löschen von Methoden und kovariante Redefinition",
        "hint": ""
    },
    {
        "id": 108,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welches Problem hat das Beispiel mit Skiern?",
        "back": "Da die Kind-Klassen Zuweisungs-kompatibel sind mit Skier, kann die Methode share vom Skier aufgerufen werden, und das Typsystem wird umgangen. Um dies zu verhindern müssen entweder die Kind-Klassen nicht Zuweisungs-kompatibel mit die Eltern-Klasse sein, die dynamische Bindung darf es nicht geben oder das Programm muss komplett auf Typ-Korrektheit überprüft werden.",
        "hint": ""
    },
    {
        "id": 109,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Verwendet Eiffel Pass-by-Reference oder Pass-by-Value?",
        "back": "Standardmäßig verwendet Eiffel Pass-by-Reference. Mit 'expanded' ist Pass-by-Value möglich, sollte jedoch nur bei Teil-Ganzes Beziehungen verwendet werden. Bei Zuweisungen zwischen Referenzen und Werten werden immer Kopien erstellt.",
        "hint": ""
    },
    {
        "id": 110,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind CAT-Calls in Eiffel und was haben sie mit dynamischer Bindung zu tun?",
        "back": "Change-Available-Type bei einer Methode sorgt dafür, dass die Methode nicht mehr dynamisch gebunden werden darf, weil Parameter-Typen überschrieben wurden. Nur durch eine Typprüfung und Cast kann eine dynamische Bindung emuliert werden.",
        "hint": ""
    },
    {
        "id": 111,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Probleme gibt es in der Objekt orientierten Programmierung?",
        "back": "Problem der Substituierbarkeit,\nFragile-base-class-Problem,\nschlechte Tracebarkeit,\neindimensionalen Strukturierung,\nmangelnde Kapselung,\nmangelnde Skalierbarkeit,\nmangelnde Eignung",
        "hint": ""
    },
    {
        "id": 112,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist das Problem der Substituierbarkeit?",
        "back": "Es geht darum, dass nicht immer gewährleistet werden kann, dass ein Sub-Typ immer an der Stelle eines Super-Typ stehen darf. Hierbei geht es um das Verhalten bzw. vor- und nach-Bedingungen die erfüllt sein müssen. Dies ist nicht immer prüfbar und sowieso Programm abhängig. (Bsp Set & Bag)",
        "hint": ""
    },
    {
        "id": 113,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Unterschied zwischen Substituierbarkeit und Zuweisungskompatibilität?",
        "back": "Zuweisungskompatibilität bedeutet, dass ein Typ die gleichen Nachrichten versteht wie ein anderer Typ und somit theoretisch an gleichen Stellen verwendet werden kann. Substituierbarkeit ist strenger und verlangt, dass die beiden Typen das gleiche Verhalten haben, also praktisch ausgetauscht werden können.",
        "hint": ""
    },
    {
        "id": 114,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist das Liskov-Substitutions-Prinzip?",
        "back": "Jede Eigenschaft die für ein Objekt des Typ T beweisbar ist, muss für alle Sub-Typen beweisbar sein.",
        "hint": ""
    },
    {
        "id": 115,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Probleme hat das Liskov-Substitutions-Prinzip?",
        "back": "Nur definiert für Objekte,\nRestriktiv (betrachtet nicht Kontext)\nSub-Typen fast gleich, wozu dann Sub-Typen?",
        "hint": ""
    },
    {
        "id": 116,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist das Fragile-base-class-Problem?",
        "back": "Das Fragile-base-class-Problem beschreibt Probleme die Auftreten, wenn in der Super-Klasse verhalten geändert wird, auf welches sich Sub-Klassen stützten. (Bsp: Sub-Klassen erwarten, dass Methode aufgerufen wird)",
        "hint": ""
    },
    {
        "id": 117,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche Möglichkeiten gibt es gegen das Fragile-base-class-Problem vorzugehen?",
        "back": "Es wird eine Art Vererbungs-Interface benötigt. Erste Ansätze sind 'protected' und 'virtual'/'override'. Diese Schlüsselwörter sollen verhindern, dass Methoden und Attribute in Sub-Klassen verwendet werden.",
        "hint": ""
    },
    {
        "id": 118,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wieso haben Objekt Orientierte Programme eine schlechte Tracebarkeit?",
        "back": "Die schlechte Tracebarkeit kommt daher, dass Sub-Typen unterschiedliche Methoden aufrufen und es nicht eindeutig ist, welche Implementation zu einem bestimmten Zeitpunkt aufgerufen wird. (dynamisches Binden)",
        "hint": ""
    },
    {
        "id": 119,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was versteht man unter dem Problem der eindimensionalen Strukturierung?",
        "back": "Der gesamte Code wird ist Klassen geschrieben, welche voneinander Erben und mit einander in Beziehung stehen. Es gibt meist viele Möglichkeiten die Klassen zu strukturieren, welche jedoch alle gewisse Nachteile haben.",
        "hint": ""
    },
    {
        "id": 120,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wieso gibt es das Problem der mangelnden Kapselung?",
        "back": "Die Vererbung durchbricht die Kapselung. Aliase können ebenfalls die Kapselung durchbrechen. Aliase sind viel zu nützlich, als dass man sie verbieten möchte (zB durch Wert-Typen)",
        "hint": ""
    },
    {
        "id": 121,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wieso gibt es das Problem der mangelnden Skalierbarkeit?",
        "back": "Höhere Sprachkonstrukte als Klasse gibt es nicht wirklich. Innere-Klassen werden kaum genutzt, Pakete Gruppieren nur Klassen jedoch werden Komponenten benötigt, die Aggregationen von Klassen ausdrücken.",
        "hint": ""
    },
    {
        "id": 122,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wieso gibt es das Problem der mangelnden Eignung?",
        "back": "Klassen-basierte OOP ist nicht für Algorithmen oder lineare Abfolgen am besten geeignet. Datenbanken und OOP haben komplett andere Konstrukte. Selbst für GUI-Programmierung ist Prototyp-basierte OOP besser geeignet.",
        "hint": ""
    },
    {
        "id": 123,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Unterschied zwischen identisch und gleich?",
        "back": "Identisch bedeutet, dass zwei Zeiger auf die gleiche Stelle im Speicher zeigen, also auf ein und dasselbe Objekt. Gleich gibt an ob zwei Objekt das gleiche Repräsentieren. (zB zwei String-Objekte mit gleichen Zeichenfolgen)",
        "hint": ""
    },
    {
        "id": 124,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Weswegen werden manche Objekte mit Wert-Semantik versehen?",
        "back": "Der Sinn dahinter ist, dass keine Aliase für dieses Objekt erzeugt werden, sondern lediglich Kopien. Objekte mit Wert-Semantik stehen meistens in einer Teil-Ganzes-Beziehung.",
        "hint": ""
    },
    {
        "id": 125,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie können Objekte in SMALLTALK in Beziehung mit einander stehen?",
        "back": "Objekte stehen in Beziehung mit einander, wenn eine Referenz vom Einem im Anderen in Form einer Instanzvariablen existiert. Es kann sich dabei um eine benannte oder indizierte Instanz-Variable handeln.",
        "hint": ""
    },
    {
        "id": 126,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie kann man die Komposition in objektorientierten Programmiersprachen umsetzen?",
        "back": "Hierfür gibt es in den meisten Programmier-Sprachen keine speziellen Konstrukte. Meist ist die Komposition ein Objekt einer Klasse, welche zur Laufzeit dynamisch zu einer Komposition zusammengesetzt wird. Nützlich ist hierfür jedoch die Wert-Semantik, welche dafür sorgt, dass die Lebensdauer der Teile auf jeden Fall mit der Lebensdauer des Ganzen endet.",
        "hint": ""
    },
    {
        "id": 127,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Zustand von Objekten und wie wird er in SMALLTALK geändert?",
        "back": "Der Zustand ist die Summe aller Instanz-Variablen eines Objekts. Nur über einen Nachrichtenversand und dann eine Zuweisung zu den Instanzvariablen kann den Zustand des Objekts ändern.",
        "hint": ""
    },
    {
        "id": 128,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Welche beiden Formen von Ausdrücken gibt es in der objektorientierten Programmierung?",
        "back": "Zuweisung und Nachrichten-Ausdruck",
        "hint": ""
    },
    {
        "id": 129,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wieso besitzt jede Klasse genau eine Meta-Klasse in SMALLTALK?",
        "back": "Der Sinn dahinter ist, dass die Klassen, als Instanzen der Meta-Klasse, eigene Instanz-Variablen und Methoden haben sollen, ohne, dass dabei an andere Klassen gedacht werden muss.",
        "hint": ""
    },
    {
        "id": 130,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Factory-Methoden?",
        "back": "Factory-Methoden sind Methoden, welche Instanzen verschiedener Klassen zurückliefern. In Sprachen wie SMALLTALK, in denen sich Klassenmethoden und Konstruktoren nicht wirklich unterscheiden sind solche Factory-Methoden leicht zu implementieren.",
        "hint": ""
    },
    {
        "id": 131,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist der Unterschied zwischen Generalisierung und Spezialisierung?",
        "back": "Während die Generalisierung Eigenschaften weglässt oder generalisiert (Abstraktion), fügt die Spezialisierung Eigenschaften hinzu oder spezialisiert bereits vorhandene.",
        "hint": ""
    },
    {
        "id": 132,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie hängen Generalisierung/Spezialisierung und Vererbung zusammen?",
        "back": "Vererbung ist eine Art, wie man Generalisierung und Spezialisierung umsetzen kann. Dabei ist die Klasse von der geerbt wird die Generalisierung von der Klasse die erbt, welche wiederum eine Spezialisierung ist.",
        "hint": ""
    },
    {
        "id": 133,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was versteht man in der objektorientierten Programmierung unter Vererbung?",
        "back": "In der Objekt Orientierung bezeichnet Vererbung eine Möglichkeit den Code eine Klasse in einer anderen Klasse wieder zu verwenden. Dabei übernimmt die Klasse, welche erbt alle Eigenschaften der anderen Klasse.",
        "hint": ""
    },
    {
        "id": 134,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist offene Rekursion?",
        "back": "Ein Objekt ruft eine abstrakte Methode auf sich selbst auf. Es ist dabei rekursiv, weil das Objekt die Methode auf sich aufruft und offen, weil noch nicht bekannt ist, weile Implementation aufgerufen wird.",
        "hint": ""
    },
    {
        "id": 135,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Typen?",
        "back": "Typen sind abstrakte Spezifikationen, die zum einen den Wertebereich von Variablen einschränken und zum anderen das Protokoll (den Funktionsumfang) von Objekten angeben.",
        "hint": ""
    },
    {
        "id": 136,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Zu welchem Zeitpunkt führt die Verwendung eines parametrisch definierten Typs zu einer Zuweisung an die Typ-Variable?",
        "back": "Zur Übersetzungszeit",
        "hint": ""
    },
    {
        "id": 137,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was sind Repräsentations-Objekte?",
        "back": "Repräsentations-Objekte machen die Implementierung eines anderen Objekts aus und bleiben hinter diesem Verborgen. (Bsp: Stack verwendet Array)",
        "hint": ""
    },
    {
        "id": 138,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist das Gesetz von Demeter",
        "back": "Sprich nicht mit Fremden. Es dürfen Methoden nur auf Instanz-Variablen und Parametern von Funktionen aufgerufen werden. (Hat praktische Grenzen)",
        "hint": ""
    },
    {
        "id": 139,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was gehört zu einem guten objektorientierten Stil?",
        "back": "Gute Bezeichner (Kommentare vermeiden, Abkürzungen Nutzen), Projekt Namens-/Formatierungs- Konventionen, Kurze Methoden, Deklarativ (eher Was statt Wie), Bibliotheken verwenden, Kurze Klassen, nur Abstrakte Super-Klassen",
        "hint": ""
    },
    {
        "id": 140,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Was ist Type-Branding?",
        "back": "Type-Branding wird bei struktureller Typ-Äquivalenz verwendet, um zu vermeiden, dass semantisch unterschiedliche Objekte vertauscht werden. Dabei wird den Typen eine charakteristische Eigenschaft wie eine Methode gegeben, sodass diese nicht mehr Typ-Äquivalent zu ähnlichen Typen sind.",
        "hint": ""
    },
    {
        "id": 141,
        "folder": "Objekt Orientierte Programmierung",
        "front": "Wie wurde die Lücke im Typ-System von Arrays mit Sub-Typen bei der parametrische Polymorphie behoben?",
        "back": "Durch das Wild-Card (*)",
        "hint": ""
    },
    {
        "id": 142,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist ein Algorithmus?",
        "back": "",
        "hint": ""
    },
    {
        "id": 143,
        "folder": "Komplexitäts Theorie",
        "front": "Wie misst man die Rechenzeit eines Algorithmus?",
        "back": "",
        "hint": ""
    },
    {
        "id": 144,
        "folder": "Komplexitäts Theorie",
        "front": "Wie lautet die Erweiterte Churche These?",
        "back": "",
        "hint": ""
    },
    {
        "id": 145,
        "folder": "Komplexitäts Theorie",
        "front": "Wie unterscheiden sich Registermaschinen und Turingmaschinen?",
        "back": "",
        "hint": ""
    },
    {
        "id": 146,
        "folder": "Komplexitäts Theorie",
        "front": "Nenne wichtige Probleme aus der Komplexitätstheorie.",
        "back": "Traveling-Sales-Man (TSP), (Directed) Hamilton-Circle, SAT, Knapsack-Problem, Bin-Packing, CLIQUE, Anti-Clique (Independent Set)",
        "hint": ""
    },
    {
        "id": 147,
        "folder": "Komplexitäts Theorie",
        "front": "Welche Komplexitäts-Klassen erlauben Versagen?",
        "back": "",
        "hint": ""
    },
    {
        "id": 148,
        "folder": "Komplexitäts Theorie",
        "front": "Welche Komplexitäts-Klassen erlauben einseitige Fehler?",
        "back": "",
        "hint": ""
    },
    {
        "id": 149,
        "folder": "Komplexitäts Theorie",
        "front": "Welche Komplexitäts-Klassen erlauben beidseitige Fehler?",
        "back": "",
        "hint": ""
    },
    {
        "id": 150,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist der Unterschied zwischen Turing-Reduktion und Polynomiell-Reduktion?",
        "back": "",
        "hint": ""
    },
    {
        "id": 151,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird SAT auf 3SAT turing-reduziert?",
        "back": "",
        "hint": "SAT <=T 3SAT"
    },
    {
        "id": 152,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird 3SAT auf CLIQUE polynomiell-reduziert?",
        "back": "",
        "hint": "3SAT <=P CLIQUE (Teilmenge jeder kennt jeden)"
    },
    {
        "id": 153,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird 3SAT auf DHC polynomiell-reduziert?",
        "back": "",
        "hint": "3SAT <=P DHC (Directed Hamilton Circle)"
    },
    {
        "id": 154,
        "folder": "Komplexitäts Theorie",
        "front": "Was bedeutet C-vollständig, C-schwer und C-äquivalent?",
        "back": "C-schwer:\nmind so schwer wie alle aus C\nC-Vollständig:\nSchwerstes Problem aus C\nC-äquivalent:\nC enthält Problem",
        "hint": ""
    },
    {
        "id": 155,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist eine alternative Definition von NP?",
        "back": "Algorithmus erzeugt randomisiert eine potenzielle Lösung. In polynomieller Zeit kann die Lösung überprüft werden. Die Fehlerwahrscheinlichkeit ist extrem hoch.",
        "hint": "Verifikation"
    },
    {
        "id": 156,
        "folder": "Komplexitäts Theorie",
        "front": "Wie beweist man die NP-Vollständigkeit eines Problems?",
        "back": "Es genügt zu zeigen, dass das Problem in NP enthalten ist und ein beliebiges anderes NP-Vollständiges Problem (zB SAT) auf das Problem zu reduzieren.",
        "hint": ""
    },
    {
        "id": 157,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Beweisidee vom Satz von Cook?",
        "back": "Das Verhalten einer Turing-Maschine wird durch Klauseln beschrieben. Die Klauseln stellen sicher, dass die Maschine korrekt startet, fortfährt und schlussendlich in einem akzeptierenden Zustand landet. Die entstandene Formel kann dann als Eingabe für SAT verwendet werden.",
        "hint": "SAT ist NP-vollständig (Wenn SAT in P, genau dann NP = P)"
    },
    {
        "id": 158,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird 3SAT auf SSS polynomiell-reduziert?",
        "back": "Pro Variable x_i werden zwei Zahlen a & b erzeugt. Die Zahlen a haben eine 1 an der Nachkommastelle i und 1ser an den j-ten Stellen, wenn sie in der j-ten Klausel nicht-negiert vorkommen. Die Zahlen b haben die gleichen Nachkommastellen aber werden auf die negierte Klausel angewandt. Die Zahlen a & b repräsentieren, ob eine Variable wahr oder falsch ist und ob eine Klausel erfüllt ist. Damit eine Formel erfüllt ist, müssen alle Nachkommastellen 1 haben. Die Zahlen vor dem Komma müssen mindestens 1 sein, damit jede Klausel erfüllt ist. Zum auffüllen gibt es pro Klausel zwei Zahlen d & e, welche an der j-ten Stelle 1 haben. So ist die Summe vor dem Komma immer genau 3 wenn eine Formel erfüllbar ist.",
        "hint": "3SAT <=P SSS (Subset Sum Problem)"
    },
    {
        "id": 159,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird SSS auf PARTITION polynomiell-reduziert?",
        "back": "Es werden zwei Zahlen a & b hinzugenommen (Erzwingende Komponente). Wenn S der Ziel-Summen-Wert ist und S* die gesamt Summen ist, dann ist a = 2S*-S und b = S*+S. Bei den Partitionen wird a zwangsläufig in einer und b in der anderen Partition landen, weil a + b über der neuen Gesamt-Summe 4S* liegt. Löst man PARTITION und lässt danach a & b weg, hat man eine Lösung für SSS.",
        "hint": "SSS (Subset Sum Problem) <=P PARTITION (Aufteilen in zwei Summen mit gleicher Größe)"
    },
    {
        "id": 160,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird PARTITION auf SWI polynomiell-reduziert?",
        "back": "Jede Zahl wird Abgebildet auf eine Aufgabe, welche so lange Dauert. Die Deadline wird für alle auf die Gesamt Summe + 1 gesetzt. Es wird eine Aufgabe hinzugefügt (Erzwingende Komponente), welche genau in der Mitte der Gesamt-Zeit bearbeitet werden muss und die Zeit 1 benötigt. Die Aufgaben müssen also in zwei Intervalle mit gleicher Größe Aufgeteilt werden welche davor und danach geschehen müssen.",
        "hint": "PARTITION (Aufteilen in zwei Summen mit gleicher Größe) <=P SWI (Sequencing with intervals)"
    },
    {
        "id": 161,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird 3SAT auf GC polynomiell-reduziert?",
        "back": "Jedes Literal wird mit zwei Knoten repräsentiert die Verbunden werden und diese sind alle mit einem Knoten v3 verbunden, welcher die dritte Farbe hat. Somit wird erzwungen, dass jedes Literal die erste und zweite Farbe hat und damit negiert oder nicht gewählt wird. v3 bildet mit v1 & v2 zusätzlich noch ein Dreieck. Für jede Klausel wird eine Struktur (≡⪩=⪧<) aufgebaut, welche erzwingt, dass mindestens eines der Literale mit der ersten Farbe gefärbt werden muss. Wenn die Dreifärbung gelingt, ist die Formel erfüllbar.",
        "hint": "3SAT <=P GC (Graph Coloring)"
    },
    {
        "id": 162,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird 3SAT auf 3-DM polynomiell-reduziert?",
        "back": "Jedes Literal wird durch je 4 Personen x_i und 4 Personen ¬x_i aus Gruppe 1 repräsentiert. Durch je 4 Personen aus Gruppe 2 & 3 (Auswahlkomponente) werden die Personen verknüpft, sodass nur Gruppen mit x_i oder Gruppen mit ¬x_i gebildet werden. Für jede Klausel gibt es zwei Personen aus Gruppe 2 & 3, welche nur mit einer Person aus der Klausel eine Gruppe bilden können. Dies repräsentiert die Erfüllbarkeit einer Klausel. Zum auffüllen gibt es nur weitere Personen aus Gruppe 2 & 3.",
        "hint": "3SAT <=P 3-DM (3/k-dimensional matching)"
    },
    {
        "id": 163,
        "folder": "Komplexitäts Theorie",
        "front": "Wie wird 3SAT auf (0,1,3)-CP polynomiell-reduziert?",
        "back": "",
        "hint": "3SAT <=P (0,1,3)-CP ((0,1,3)-Championship-problem)"
    },
    {
        "id": 164,
        "folder": "Komplexitäts Theorie",
        "front": "Was bedeutet starte NP-Vollständigkeit und pseudo-polynomieller Algorithmus?",
        "back": "Starke NP-Vollständigkeit bedeutet, dass ein NP-vollständiges Problem, für Eingaben, welche durch ein Polynom beschränkt sind, weiterhin NP-vollständig sind. Ein Beispiel wäre TSP, da TSP mit Distanzen 1 & 2 bereits NP-vollständig ist. Existiert ein pseudo-polynomieller Algorithmus für ein Problem, so ist das Problem nicht stark NP-vollständig.",
        "hint": ""
    },
    {
        "id": 165,
        "folder": "Komplexitäts Theorie",
        "front": "Wie funktioniert der pseudo-polynomielle Algorithmus für KP und welche Bedeutung hat dieser?",
        "back": "Der Algorithmus baut eine Tabelle auf mit der Zeilen-Anzahl n und der Spalten-Anzahl V, wobei V die Summe aller Werte der Gegenstände ist. Dabei bedeutet die k-te Zeile, dass die ersten k Gegenstände verfügbar sind. Die j-te Spalte sagt aus, welches Gewicht nötig ist ein exaktes Gewicht zu erhalten. Die Tabelle wird Zeilenweise ausgefüllt, wobei Ergebnisse aus vorherigen Zeilen wiederverwendet werden. Die Laufzeit ist polynomiell, wenn die Gesamt-Summe V polynomiell in n ist. Wegen diesem Algorithmus ist KP nicht stark NP-vollständig.",
        "hint": "KP (knapsack-problem)"
    },
    {
        "id": 166,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Approximations-Güte eines Algorithmus und wie misst man diese?",
        "back": "Die Approximations-Güte r_A(x) eines Algorithmus ist der Quotient, welcher angibt, wie nahe die Approximierte Lösung für eine bestimmte Eingabe am Optimum liegt. Am wichtigsten ist meist die maximale Approximations-Güte. Zudem gibt es die asymptotische maximale Approximations-Güte r_A^inf.",
        "hint": ""
    },
    {
        "id": 167,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Klasse APX?",
        "back": "APX enthält Algorithmen, welche einen exakten konstanten Faktor c vom Optimum entfernt sind.",
        "hint": ""
    },
    {
        "id": 168,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Klasse PTAS?",
        "back": "PTAS enthält Algorithmen, welche für ein gewähltes konstantes epsilon polynomielle Laufzeit haben und eine Approximations-Güte von 1 + epsilon besitzen.",
        "hint": ""
    },
    {
        "id": 169,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Klasse FPTAS?",
        "back": "FPTAS enthält Algorithmen, welche für ein gewähltes konstantes epsilon polynomielle Laufzeit in der Eingabe als auch in 1/epsilon haben und eine Approximations-Güte von 1 + epsilon besitzen.",
        "hint": ""
    },
    {
        "id": 170,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist Klasse NPO?",
        "back": "NPO ist das Gegenstück zu NP angewandt auf Optimierungsprobleme. Für eine Eingabe ist in polynomieller Zeit möglich die Zulässigkeit und den Wert zu berechnen. MAX-NPO und MIN-NPO sind die Probleme für Maximierung und Minimierung. Ein Problem aus MAX-NPO ist MAX-W-SAT (SAT mit Gewichten pro Klausel insgesamt maximieren) und ein Problem aus MIN-NPO ist MIN-W-SAT (SAT mit Gewichten pro Klausel insgesamt minimieren).",
        "hint": ""
    },
    {
        "id": 171,
        "folder": "Komplexitäts Theorie",
        "front": "Wieso ist MAX-W-SAT NPO-vollständig?",
        "back": "Offensichtlich gehört MAX-W-SAT zu MAX-NPO. Eine Nicht-deterministische Turing-maschine kann eine Lösung mit Polynomieller Länge erzeugen falls eine existiert. Die Lösung und der Wert der Lösung kann auf das Band geschrieben werden. Diese Turingmaschine kann wie im Beweis von Cook durch eine Logische Formel repräsentiert werden. Die Gewichte werden so gewählt, dass v(x, s) entsteht. Diese Formel ist eine Eingabe für MAX-W-SAT.",
        "hint": ""
    },
    {
        "id": 172,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist <=_PTAS?",
        "back": "Ein Optimierungs-Problem wird auf ein anderes Optimierungsproblem aus PTAS reduziert. Das Unterprogramm wird dabei nur einmal aufgerufen. APX-Reduktion funktioniert analog. Es werden die Abbildungen f (Eingabe A -> Eingabe B), g ((Eingabe A, Lösung B, epsilon) -> Lösung A), alpha (bildet epsilon ab) benötigt.",
        "hint": "PTAS-Reduktion"
    },
    {
        "id": 173,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Polynomielle Hierarchie?",
        "back": "Die Polynomielle Hierarchie ist definiert durch Algorithmen, welche Zugriff auf Orakel bekommen. Ein Orakel kann in konstanter Zeit ein bestimmtes Problem lösen. Dabei sind Σ2=NP(NP(P)) und Π2=coNP(NP(P)) und Δ2=P(NP(P)). Diese Klassen enthalten Probleme, welche durch einen (nicht-)deterministischen polynomiellen Algorithmus mit Zugriff auf ein Orakel aus der jeweiligen Komplexitätsklasse, gelöst werden können. Alle Klassen der Polynomiellen Hierarchie sind in PSPACE (Alle Probleme die mit polynomiellem Speicherplatz gelöst werden können) enthalten.",
        "hint": ""
    },
    {
        "id": 174,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist ein Interaktives Beweissystem?",
        "back": "Ein Interaktives Beweissystem besteht aus einem Beweiser und einem Verifizierer, welche je nach Eingabe Abwechselnd Nachrichten senden. Der Beweiser hat dabei unbeschränkte Rechenzeit, während der Verifizierer nur polynomielle Rechenzeit hat. Zum Schluss muss der Verifizierer die Eingabe akzeptieren oder ablehnen. Kleine Fehlerwahrscheinlichkeiten sind erlaubt. Fehler können gesenkt werden, indem eine Nachricht aus polynomiell vielen Sub-Nachrichten bestehen. Die Anzahl der Nachrichten bleibt dabei konstant.",
        "hint": ""
    },
    {
        "id": 175,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Komplexitätsklasse IP?",
        "back": "Probleme aus IP können von einem Interaktiven Beweissystem gelöst werden, wobei die Fehler hierbei unter 1/4 in beide Richtungen sein müssen. Bei IP(k) gibt k die Anzahl der Kommunikationsrunden an.IP = PSPACE (Alle Probleme die mit polynomiellem Speicherplatz gelöst werden können).",
        "hint": ""
    },
    {
        "id": 176,
        "folder": "Komplexitäts Theorie",
        "front": "Was sind zero-knowledge proofs?",
        "back": "Es handelt sich um ein Beweissystem, für ein Entscheidungsproblem, aus zwei Randomisierten Algorithmen B und V. Dabei muss es möglich sein den Algorithmus V auszutauschen, ohne, dass ",
        "hint": ""
    },
    {
        "id": 177,
        "folder": "Komplexitäts Theorie",
        "front": "Was sind computational zero-knowledge proofs?",
        "back": "Falls es eine Einwegfunktion gibt, sodass B (aus einem Beweissystem) Beweisen kann ohne sein Geheimnis Preis zu geben. (B wendet eine Einwegfunktion auf sein Geheimnis an, und veröffentlicht dies)",
        "hint": "zero-knowledge-Eigenschaft unter kryptographischen Annahmen"
    },
    {
        "id": 178,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Komplexitätsklasse PCP(r(n), q(n))?",
        "back": "O(r(n)) random bits und O(q(n)) query bits, wobei jeder Beweisversuch von WAHR klappt und jeder Beweis versuch für FALSCH höchstens die Wahrscheinlichkeit 50% hat. Dabei gilt:\nP = PCP(0, 0)\nNP = PCP(0, poly)\nco-RP = PCP(poly, 0)\nNP = PCP(log n, poly)\nNP = PCP(log n, 1)",
        "hint": ""
    },
    {
        "id": 179,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist die Beweisidee hinter 3-SAT in PCP(n^3, 1) (bzw NP ⊆ PCP(n^3, 1))?",
        "back": "Die Klauseln werden auf Parität überprüft, wobei zufällig Klauseln ausgeblendet werden. Konkret gibt es dabei mehrere Module, welche insgesamt konstant viele Beweis-Bits lesen.",
        "hint": ""
    },
    {
        "id": 180,
        "folder": "Komplexitäts Theorie",
        "front": "Wie stehen Klassen der Polynomielle Hierarchie in Bezug auf randomisierte Klassen?",
        "back": "P(P) = P\nNP(NP) ?= NP\nBPP(BPP) = BPP\nBPP ⊆ Σ2\nBPP ⊆ RP(NP) ∩ coRP(NP)",
        "hint": ""
    },
    {
        "id": 181,
        "folder": "Komplexitäts Theorie",
        "front": "Wie werden Komplexitäts Klassen für die Resource Platz definiert?",
        "back": "Die Eingabe ist auf einem read-only Band, auf dem Arbeitsband gibt es nur Zellen mit Adressen >= 1. Die Metrik ist die größte Zelle die auf dem Arbeitsband besucht wird.\n\nDTAPE(s(n)): Platz ⌈s(|x|)⌉ für deterministisch\nNTape(s(n)): Platz ⌈s(|x|)⌉ für nicht-deterministisch\n\nPSPACE = alle DTAPE(n^k) k ∈ N\nNPSPACE = alle NTAPE(n^k) k ∈ N\n\nCSL (Context-Sensitive-Languages) = NTAPE(n)",
        "hint": ""
    },
    {
        "id": 182,
        "folder": "Komplexitäts Theorie",
        "front": "Welchen Speicherbedarf hat eine deterministische Turingmaschine die eine nicht-deterministische simuliert, was ist dazu nötig?",
        "back": "Die Berechnung muss in Zeit 2^O(log(n)+s(n)) und Platz s(n) sein, dann kann eine Tiefen-Suche auf einem Graphen mit der Größe 2^O(log(n)+s(n)) gemacht werden, welcher die verschiedenen Zustände während der Berechnung repräsentiert. Platz und Zeit der deterministischen Maschine sind 2^O(log(n)+s(n)).",
        "hint": ""
    },
    {
        "id": 183,
        "folder": "Komplexitäts Theorie",
        "front": "Wie ist die Sortierung der gängigen Komplexitätsklassen bezogen auf Speicherplatz?",
        "back": "DTAPE(log(n)) ⊆ NTAPE(log(n)) ⊆ P ⊆ NP ⊆ Σk (k>=1) ⊆ PSPACE = NPSPACE",
        "hint": ""
    },
    {
        "id": 184,
        "folder": "Komplexitäts Theorie",
        "front": "Welche Verallgemeinerung von SAT ist in Σk-vollständig, welche ist PSPACE-vollständig?",
        "back": "Σk: SAT_cir^k\nPSPACE: QBF (quantified boolean formula, bsp: ∀x1 ∃x2: (x1 ∧ x2) ∨ (¬x1 ∧ x2)); Durch den Einsatz von All-Quantoren kann die Formel, welche den Pfad im Konfigurationsgraph statt exponentiell, polynomiell in der Größe ausgedrückt werden.",
        "hint": ""
    },
    {
        "id": 185,
        "folder": "Komplexitäts Theorie",
        "front": "Was ist der Satz von Savitch?",
        "back": "Wenn s(n) >= log(n) platz-konstruierbar, dann NTAPE(s(n)) ⊆ DTAPE(s(n)^2). Dafür wird anfangs Platz reserviert um zu bestimmen, welchen Rechenweg man ausprobiert. Danach wird jeder Rechenweg ausprobiert. Hierzu wird rekursiv der Konfigurationsgraph durchsucht. Der Speicher nach jedem Rechenweg wird stets bereinigt. Dieser Ansatz verwendet zwar sehr viel mehr Rechenzeit, aber in Bezug auf Speicher ist diese Strategie effizient. Speicherverbrauch: Speicher von rekursivem Rechenweg (O(f(n))) * Rekursionstiefe (O(log2(2^(d * f(n)))) = O(d * f(n))) = O(f(n)^2 * d) (= O(f(n)^2), weil d der Branching-faktor des Problem ist und konstant ist (nicht von der Eingabe abhängt))",
        "hint": ""
    },
    {
        "id": 186,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 187,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 188,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 189,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 190,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 191,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 192,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 193,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 194,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 195,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 196,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 197,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 198,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 199,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 200,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 201,
        "folder": "Komplexitäts Theorie",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 202,
        "folder": "Information Hiding",
        "front": "Was sind die drei Kern-Konzepte von Information Hiding?",
        "back": "Capacity/Bandwidth (wie viel?)\nRobustness (zB Error correction)\nSecrecy/Stealthiness/Detectability (wie schwer zu entdecken?)",
        "hint": ""
    },
    {
        "id": 203,
        "folder": "Information Hiding",
        "front": "Wieso bilden Capacity, Robustness und Secrecy ein Dreieck?",
        "back": "Optimieren eines führt zu Verlust von anderen (Wenn zB Capacity erhöht wird, sinkt Secrecy.)",
        "hint": ""
    },
    {
        "id": 204,
        "folder": "Information Hiding",
        "front": "Was sind einige Themengebiete von Information Hiding?",
        "back": "Anonymity (Sender/Empfänger verstecken)\nCovert Channel (Informationen in Resource verstecken un-gedacht dafür)\nCryptography (Information unverständlich machen)\nObfuscation (Informationen unkenntlich machen, Programm-Code Funktionalität weiterhin gleich)\nSteganographie (Informationen in Objekt speichern, meist in Covert Channel bei Network)\nWatermarking (Information über Objekt in Objekt speichern, meist erkennbar durch Maschinen)",
        "hint": ""
    },
    {
        "id": 205,
        "folder": "Information Hiding",
        "front": "Welche Arten von Steganographie und Watermarking gibt es?",
        "back": "Network Stg, Media Stg, Text Stg, Filesystem Stg, Cyber-Physical Systems (mind eine Physische Komponente zB Messbare Temperatur) Stg, Audio Watermarking, Image Watermarking",
        "hint": ""
    },
    {
        "id": 206,
        "folder": "Information Hiding",
        "front": "Ist das anwenden von Information Hiding gut oder schlecht? Wie sieht es mit Gegenmaßnahmen aus?",
        "back": "Kann für beides verwendet werden.\ngut:\nJournalist schickt Informationen unterdrückt von Regime (Deniability nötig um unentdeckt zu bleiben)\nschlecht:\nCyber-Kriminelle verteilen Informationen über System (Reversibility nötig um zu vertuschen)\n\nFür Gegenmaßnahmen gilt das gleiche.",
        "hint": ""
    },
    {
        "id": 207,
        "folder": "Information Hiding",
        "front": "Wie verfährt man beim entdecken einer neuen Information Hiding Methode?",
        "back": "Entweder man veröffentlicht nur Oberfläche Informationen oder Details mit Gegenmaßnahmen.",
        "hint": ""
    },
    {
        "id": 208,
        "folder": "Information Hiding",
        "front": "Wo kann Text-Steganographie angewendet werden?",
        "back": "geschriebener/gedruckter Text, digitales Text-Dokument, Text-Stream (zB Teleprompter)",
        "hint": ""
    },
    {
        "id": 209,
        "folder": "Information Hiding",
        "front": "Was sind Gegenmaßnahmen für LSB Steganographie in Bildern?",
        "back": "Benachbarte Pixel haben viele LSB wechsel. Gegenmaßnahmen zu Gegenmaßnahmen sind Bereiche im Bild mit konstanter Farbe zu meiden und Nachricht kurz halten",
        "hint": ""
    },
    {
        "id": 210,
        "folder": "Information Hiding",
        "front": "Welche Arten von Text-Steganographie gibt es?",
        "back": "Semantisch: Wörter/Buchstaben ersetzten\nGraphisch: Symbole einfügen/entfernen\nGeometrisch: Positionen ändern",
        "hint": ""
    },
    {
        "id": 211,
        "folder": "Information Hiding",
        "front": "Was sind physikalische Covert Channels?",
        "back": "Zwei Prozesse/Computer brauchen eine gemeinsame Resource, wobei ein Prozess lesen und der andere Prozess schreiben können muss. Ressourcen können Dateien, aber auch angeschlossene Hardware sein (zB Camera, Mikro, Lautsprecher, LED, ...).\nDarstellbar als Matrix (Shared Resource Matrix, SRM): Prozesse * Ressourcen",
        "hint": ""
    },
    {
        "id": 212,
        "folder": "Information Hiding",
        "front": "Was ist der Unterschied zwischen Covert und Side Channels?",
        "back": "Ein Covert Channel ist nicht gedacht für Austausch von Informationen. Ein Side-Channel ist ein Covert-Channel, bei dem der Austausch unbeabsichtigt statt findet. (Algorithmus läuft schneller bei bestimmter Eingabe)",
        "hint": ""
    },
    {
        "id": 213,
        "folder": "Information Hiding",
        "front": "Was sind Steganographische Dateisysteme? Welche Probleme gibt es dabei?",
        "back": "3 Varianten: Dateisystem in Cover-Objekt speichern, versteckte Nachricht in Dateisystem speichern, verstecktes Dateisystem in Dateisystem speichern\n\nProbleme treten auf, da Dateisysteme nicht statisch sind und deswegen Änderungen möglich sein müssen. Außerdem muss eine gewisse Redundanz vorhanden sein.",
        "hint": ""
    },
    {
        "id": 214,
        "folder": "Information Hiding",
        "front": "Wie können Steganographische Dateisysteme funktionieren?",
        "back": "XOR-Zwischen verschiedenen Dateien liefert versteckte Datei. Datei Reihenfolge enthält versteckte Nachricht. Versteckte Daten in Datei Meta-Daten oder ungenutzten Speicher-Blöcken speichern. Dateisystem in Sammlung von Bildern auf Server speichern.",
        "hint": ""
    },
    {
        "id": 215,
        "folder": "Information Hiding",
        "front": "Was sind Gegenmaßnahmen zu Steganographische Dateisystemen?",
        "back": "Entdecken reicht aus (Szenario von Regime: Gewalt reicht für den Rest). Dynamische Analyse während Gebrauch (Nutzer muss dafür auf Geheime Daten zugreifen), Statische Analyse: Analyse von Logs. (Anti-Gegenmaßnahme: Logs modifizieren)",
        "hint": ""
    },
    {
        "id": 216,
        "folder": "Information Hiding",
        "front": "Wie kann ein Covert Channel definiert werden mit Hilfe des Bell-LaPadula (BLP) Modell?",
        "back": "Prozesse mit höherer Berechtigung dürfen Lesen von Prozessen mit niedriger Berechtigung und Prozesse mit niedriger Berechtigung dürfen Informationen an Höhere senden. Ein Covert-Channel wäre Senden an Niedrigere (write-down) oder Lesen von Höheren (read-up)",
        "hint": ""
    },
    {
        "id": 217,
        "folder": "Information Hiding",
        "front": "Wie können Covert Channel identifiziert oder behindert werden?",
        "back": "Shared Resource Matrix (Read-Write-Paare finden), extended Resource Matrix, Covert Flow Trees (Source Code analysieren und Sequenzen bilden), Fuzzy-Time: Timing covert-channel wird durch ungenaue Zeitstempel von Virtuellen Maschinen stark gedrosselt, Spurious Process Ansatz: Covert Channel wird durch Prozess gestört, welcher Prozess 1 imitiert und somit Prozess 2 verwirrt",
        "hint": ""
    },
    {
        "id": 218,
        "folder": "Information Hiding",
        "front": "Welche Angriffs-Möglichkeiten gibt es gegen Wasserzeichen?",
        "back": "Dateiformat oder Auflösung ändern (Wasserzeichen entfernen/beschädigen), verschiedene Varianten mit Wasserzeichen untersuchen und eigenes Wasserzeichen setzen.",
        "hint": ""
    },
    {
        "id": 219,
        "folder": "Information Hiding",
        "front": "Welche Varianten von Wasserzeichen gibt es?",
        "back": "Robuste Wasserzeichen (Wasserzeichen übersteht starke Änderungen), Fragile Wasserzeichen (Wasserzeichen übersteht nur valide Änderungen) und Digital Fingerprinting (Robust gegen Angriffe sogar wenn mehrere Kopien mit verschiedenen Wasserzeichen vorhanden sind)",
        "hint": ""
    },
    {
        "id": 220,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 221,
        "folder": "Information Hiding",
        "front": "Was ist ein 'Ping Tunnel'?",
        "back": "Ein 'Ping Tunnel' kann verwendet werden um Daten von einem Client zu einem Ziel zu schicken, wobei das Ziel nicht über TCP direkt erreichbar ist. Es wird dabei eine indirekte Verbindung über einen Proxy hergestellt, welcher ein TCP-Verbindung aufbauen kann. Der Client kommuniziert mit dem Proxy dabei über ICMP.",
        "hint": ""
    },
    {
        "id": 222,
        "folder": "Information Hiding",
        "front": "Was sind storage, timing, noisy, noise-free, aktiv, passiv, direkt, indirekt covert channels?",
        "back": "storage: Information in Nachricht gespeichert\ntiming: Information zeitlichen 'gespeichert'\nnoisy: Cover-Objekt könnte abgeändert werden (realistisch)\nnoise-free: Cover-Objekt bleibt exakt erhalten (ideal)\naktiv: Sender & Empfänger erzeugen und lesen Nachrichten\npassiv: Sender & Empfänger verwenden Kommunikation von anderen\ndirekt: Sender & Empfänger senden Nachrichten direkt\nindirekt: Sender & Empfänger senden Daten an einen dritten (nimmt unbeabsichtigt Teil)",
        "hint": ""
    },
    {
        "id": 223,
        "folder": "Information Hiding",
        "front": "Was ist 'Steganographic cost'?",
        "back": "'Steganographic cost' ist ein Maß für die Abänderung/Verzerrung des Cover-Objekt und muss für jede Methode unterschiedlich definiert werden. (Methode welche Paket-Verlust verwendet und Methode die Pakete erneut schickt können nicht die gleiche Definition verwenden)",
        "hint": ""
    },
    {
        "id": 224,
        "folder": "Information Hiding",
        "front": "Was sind 'Hiding Patterns'?",
        "back": "Ein 'Hiding Pattern' zeigt den Kern eine Methode auf und wird abstrakt gehalten. Es werden somit details weggelassen, wodurch die Terminologie einheitlich bleibt. Sie können mit PLML () beschrieben werden. Der Nutzen eines Pattern ist, dass sehr viele Methoden (zB 109) von wenigen Patterns (zB 11) beschrieben werden können.",
        "hint": ""
    },
    {
        "id": 225,
        "folder": "Information Hiding",
        "front": "Wie werden Network Covert Channel Patterns Unterteilt?",
        "back": "Covert Timing {Protocol agnostic (unaware), Protocol aware}, Covert Storage {Non-Payload {Structure Modifying, Structure Preserving}, Payload {User-data agnostic (unaware), User-data aware}}",
        "hint": ""
    },
    {
        "id": 226,
        "folder": "Information Hiding",
        "front": "Welche Covert Timing Protocol agnostic Patterns gibt es?",
        "back": "Inter-packet times, message sequence timing (Pakete mehrfach senden/ack zu bestimmten Zeiten senden), Rate/Throughput Pattern (Datenrate variieren)",
        "hint": ""
    },
    {
        "id": 227,
        "folder": "Information Hiding",
        "front": "Welche Covert Timing Protocol aware Patterns gibt es?",
        "back": "Artificial Packet loss, Message Ordering (verwendet sequence number), Artificial Re-Transmission, Frame Collision (Kollision muss erkennbar sein), Temperature (Clock wird von Sender erhitzt und kann von Receiver durch polling erkannt werden), Artificial Re-Connection (Sender trennt Verbindungen, Receiver erkennt re-connections), Artificial Resets (Sender erzeugt reset einer Verbindung, Receiver erkennt Verbindungszustand)",
        "hint": ""
    },
    {
        "id": 228,
        "folder": "Information Hiding",
        "front": "Welche Covert Storage Non-payload structure modifying Patterns gibt es?",
        "back": "Size Modulation (Paket Größe variieren), Sequence Modulation (Reihenfolge innerhalb meta-daten) {Position, Number of Elements}, Add Redundancy (unnötige header hinzufügen)",
        "hint": ""
    },
    {
        "id": 229,
        "folder": "Information Hiding",
        "front": "Welche Covert Storage Non-payload structure preserving Patterns gibt es?",
        "back": "Random Values (Zufällige werte in Attribut), Value Modulation Pattern (Attribut plausibel abändern) {Case (upper/lower), LSB (least significant bit)}, Reserved/Unused (nicht verwendete Bits ausnutzen)",
        "hint": ""
    },
    {
        "id": 230,
        "folder": "Information Hiding",
        "front": "Welche Covert Storage payload user-data agnostic Patterns gibt es?",
        "back": "Payload field size Modulation, User-data corruption (blind modification)",
        "hint": ""
    },
    {
        "id": 231,
        "folder": "Information Hiding",
        "front": "Welche Covert Storage payload user-data aware Patterns gibt es?",
        "back": "Modify redundancy (via transcoding: platz schaffen durch stärkere Kompression), User-data value modulation & Reserver/Unused (targeted modification",
        "hint": ""
    },
    {
        "id": 232,
        "folder": "Information Hiding",
        "front": "Was ist der Unterschied zwischen Embedding Patterns und Representation Patterns?",
        "back": "Embedding: Wie Informationen embedded werden\nRepresentation: Wie Informationen Repräsentiert werden",
        "hint": ""
    },
    {
        "id": 233,
        "folder": "Information Hiding",
        "front": "Welche embedding temporal modulation patterns gibt es?",
        "back": "Event Interval Modulation (Zeitliche Abstände variieren) {Rate/Throughput Modulation}, Event Occurrence (Zeitpunkt(e) von Event)",
        "hint": ""
    },
    {
        "id": 234,
        "folder": "Information Hiding",
        "front": "Welche embedding non-temporal patterns gibt es?",
        "back": "Artificial Element-loss (Pakete, Komma's, ...), Elements/Features Positioning, Elements/Features Enumeration (Duplikate/Anzahlen), State/Value Modulation (Attribute ändern) {reserver, random, blind}, Feature Structure Modulation (Inhalt bleibt gleich) {size feature, character feature}",
        "hint": ""
    },
    {
        "id": 235,
        "folder": "Information Hiding",
        "front": "Was sind distributed Hiding Methods?",
        "back": "Protocol Hopping: Informationen über verschiedene Channel verteilen\nProtocol Switching: Reihenfolge von Protokollen bestimmt Nachricht.\n\nCombination Pattern, Hopping Pattern & Pattern Variation (Host-based scattering, Flow-based scattering & Protocol-based scattering)",
        "hint": ""
    },
    {
        "id": 236,
        "folder": "Information Hiding",
        "front": "Was ist das Combination Pattern?",
        "back": "Es werden mehrere Methoden auf einmal angewandt. (Bsp: size modulation von packet + value modulation von TTL)",
        "hint": ""
    },
    {
        "id": 237,
        "folder": "Information Hiding",
        "front": "Was ist das Pattern Hopping?",
        "back": "Es wird zwischen verschiedenen Patterns gewechselt. (Bsp: Protocol Hopping) Es ist dabei aber immernoch ein Flow, bei mehreren Flow's wäre es (auch) Flow-based scattering (Untergruppe von Pattern Variation)",
        "hint": ""
    },
    {
        "id": 238,
        "folder": "Information Hiding",
        "front": "Was ist Host-based scattering, Flow-based scattering & Protocol-based scattering?",
        "back": "Host-based: Ein Pattern wird andewandt, aber über mehrere Hosts verteilt (Bsp: Host mit mehreren IP-Addressen)\nFlow-based: mehrere 'flows' (Stränge) mit einem Pattern\nProtocol-based: auf mehrere Protokolle wird ein Pattern angewandt",
        "hint": ""
    },
    {
        "id": 239,
        "folder": "Information Hiding",
        "front": "Was ist Pattern Variation?",
        "back": "Ein generisches Pattern beschreibt nur die Idee eines Hiding Pattern. Die Variationen sind konkrete Anwendungen des Pattern auf ein Protocol (zB eine varation für IPv4 und eine für IPv6)",
        "hint": ""
    },
    {
        "id": 240,
        "folder": "Information Hiding",
        "front": "Was sind adaptive Hiding Methoden?",
        "back": "Adaptive Hiding Methoden passen sich an die Umgebung. Es gibt NEL, Dynamic Overlay Routing for Covert Channels",
        "hint": ""
    },
    {
        "id": 241,
        "folder": "Information Hiding",
        "front": "Was ist die adaptive Hiding Methode NEL?",
        "back": "NEL (Network Environment Learning) ist eine Methode welche sich kontinuierlich an die 'Umgebung' anpasst. Es wird untersucht, welche Protokolle in Frage kommen (bzw welche zB von einer Fire-Wall gefiltert werden). Falls eine Kommunikation auf einem Weg möglich ist, wird dieser Weg verwendet, ansonsten werden andere Wege untersucht. Ein Man-in-the-middle kann relativ leicht die Kommunikation unterbinden, weil die Beteiligten nur passiv überwachen. Durch einen separaten Kanal, über den die Beteiligten aktiv austauschen können, welchen Kommunikationsweg sie als nächstes austesten kann die Methode verbessert werden.",
        "hint": ""
    },
    {
        "id": 242,
        "folder": "Information Hiding",
        "front": "Was ist Dynamic Overlay Routing for Covert Channels?",
        "back": "Es wird die Umgebung analysiert, um den besten Weg für eine Kommunikation zu bestimmen. Dabei ist ein Teil der übermittelten Nachricht ein control (micro) protocol. Es enthält (meta) Informationen über den momentanen Zustand/Kommunikationsweg und die eigendliche Nachricht. Vorteile sind: zuverlässigkeit (ack kann zB gesendet werden), aufgebautes netzwerk kann gemanaged werden, routing kann sich ändern, Nodes können geupdated werden, Nodes können sich entdecken, Protokolle können gewechselt werden. Das control (micro) protocol muss für den Empfänger von anderen Nachrichten unterscheidbar sein, um falsche interpretation von Nachrichten zu vermeiden.",
        "hint": ""
    },
    {
        "id": 243,
        "folder": "Information Hiding",
        "front": "Wie sollten Protokolle bei Multi-Pattern Methoden gewählt werden?",
        "back": "Grundlegend sollten mehrere Protokolle verwendet werden um die Sicherheit zu erhöhen. Ansonsten ist es entscheidend, ob die Nachricht dringlich ist, die Nachricht sehr groß ist oder die stealthiness am wichtigsten ist. Je nach dem können die einzelnen verfügbaren Protokolle gewichtet werden und zufällig gewählt werden.",
        "hint": ""
    },
    {
        "id": 244,
        "folder": "Information Hiding",
        "front": "Was ist Micro Protocol Engineering?",
        "back": "Aus einem zugrunde liegenden Protokoll (zB IPv4) wird ein Micro Protocol erzeugt. Hierfür werden die Wahrscheinlichkeiten für die verschiedenen Bits des Protokoll untersucht. Das gleiche wird für das zu erzeugende Micro Protocol gemacht. Die Bits werden danach so aufeinander abgestimmt, dass die Wahrscheinlichkeiten zu einander passen. Zuletzt wird überprüft, ob das zugrunde liegende Protokoll nicht verletzt wird. (Unmögliche Bit-Kombinationen, welche leicht erkennbar wären, durch zB 'Language-inclusion-Test') Falls dies der Fall ist, müssen Änderungen an den Protokollen oder am Mapping vorgenommen werden. (Es ist auch möglich beim Mapping die 0/1 Bits zweier Bits zu vertauschen, falls die Wahrscheinlichkeiten so besser abgebildet werden)",
        "hint": ""
    },
    {
        "id": 245,
        "folder": "Information Hiding",
        "front": "Was ist reversible data hiding (RDH)?",
        "back": "Sender und Empfänger verwenden legitime Kommunikation und ändern diese beide ab. Die legitime Kommunikation wird dadurch nicht gestört. Es gibt 'fully-reverable', 'quasi-reversible' & 'non-reversible'. Die Nachricht zu entfernen, kann entweder 'intrinsic' (Methode erlaubt einfaches entfernen), 'explicit' (es wird original Zustand in Nachricht gespeichert) & 'implicit' (statistisch) sein",
        "hint": ""
    },
    {
        "id": 246,
        "folder": "Information Hiding",
        "front": "Was ist ein Redirector, Broker, Proxy & Deaddrop?",
        "back": "Instanz (Redirector) zwischen Sender und Empfänger leitet Nachrichten (un)absichtlich weiter. Bei Proxy & Dead-Drop (beides Broker) kann Empfänger Nachrichten aus Instanz extrahieren. Proxy: Instanz repräsentiert Nachricht (zB Load), welche gemessen werden kann. Dead-Drop: Instanz speichert Nachricht in Cache, welcher von Empfänger (später) gelesen werden kann.",
        "hint": ""
    },
    {
        "id": 247,
        "folder": "Information Hiding",
        "front": "Was sind Gegenmaßnahmen für Network Steganography?",
        "back": "Verhindern:\nTraffic Normalizer: aufwendig, Probleme bei re-transmission, cold-start (normailzer startet mitten drin), zu viel Zustand (evtl DOS)\n\nBegrenzen\n\nErkennen:\nPaket Zeitpunkte messen (gegen Inter-Packet times pattern) -> berk et al (prob = 1 - abs(maxbin - avg)) oder ɛ-similarity (sort -> diff -> detect spikes) oder encodieren und compression ratio bestimmen\nSequence-Number diff, encodieren und compression\nRe-transmission mit ɛ-similarity (andere Grenze) und mit compressibility (anderes encoding) aber evtl nicht effektiv\nSize-Modulation compressibility oder ɛ-similarity beide relativ aufwendig (viele Grenzen nötig um verschiedene Varianten zu erkennen)\n\nEs gibt auch Jaccard similarity, st-dev bestimmen",
        "hint": ""
    },
    {
        "id": 248,
        "folder": "Information Hiding",
        "front": "Warum sind bereits wenige False-Positive problematisch bei Gegenmaßnahmen für Network Steganography?",
        "back": "Es muss in Echtzeit analysiert werden und bei hohen Daten-Raten wie 10Gbit/s sind dies bereits sehr viele Sonderfälle, welche betrachtet werden müssen.",
        "hint": ""
    },
    {
        "id": 249,
        "folder": "Information Hiding",
        "front": "Bei Gegenmaßnahmen für Network Steganography, welche 'Warden' gibt es?",
        "back": "Behavior (passiv/aktiv, zustandslos, proaktiv/reaktiv (Aktionen ausführen), Dokumentieren, statisch/dynamisch (anpassen an situation)), Structure (distributed (mehrere arbeiten zusammen), Single-Hop/LAN/WAN, Menge Rechenpower/Rechte) & Knowledge (kennt Topologie (kann TTL monitoren), kennt Methode ganz/etwas oder nicht, kennt embedding/extraction/control process)",
        "hint": ""
    },
    {
        "id": 250,
        "folder": "Information Hiding",
        "front": "Was ist minimal requesite fidelity?",
        "back": "Minimal requesite fidelity ist eine Metrik zum bestimmen, wie stark eine Gegenmaßnahme regulären Verkehr stört. (Ähnlich wie steganograpic cost, aber für Gegenmaßnahmen)",
        "hint": ""
    },
    {
        "id": 251,
        "folder": "Information Hiding",
        "front": "Wie kann (im BLP kontext) steganographie unterbunden werden?",
        "back": "Write-down bzw Read-up werden verhindert durch 'Blind Write-up'. Hierbei sind ACK jedoch nicht (mehr) möglich (Sonst ACK-Channel). Für mehr Zuverlässigkeit kann ein 'Upwards Channel' verwendet werden. Hierbei wird ein Buffer verwendet, falls Daten zu schnell übermittelt werden. Falls ACK erwünsch sind, können Nachrichten in Buffer gespeichert werden und direkt ACK erhalten (Store & Forward Protocol, Probleme bei vollem Buffer) oder Buffer wird regelmäßig geleert und ACK wird zu zufälligem Zeitpunkt verschickt (Pump). Sobald ACK vorhanden ist, ist ein Channel möglich, aber mit den Methoden kann dieser wenigstens stark reduziert werden.",
        "hint": ""
    },
    {
        "id": 252,
        "folder": "Information Hiding",
        "front": "Was sind Gegenmaßnahmen für Protocol-Switching Covert Channel? (Protokolle repräsentieren Information, nicht Protocol Hopping)",
        "back": "Protocol Channel-aware active Warden: Pakete von einer Sender-Empfänger-Verbindung werden verzögert, falls es unterschiedliche Protokolle sind (Bitrate wird reduziert auf 1 Bit/s für Verzögerung von 2sec).\n\nVerzögerung kann auch zufällig gewählt werden. Angreifer kann diese nicht bestimmen und sich nicht (gut) anpassen. Nachricht wird noch mehr gestört.\n\nDynamic Warden: gegen NEL (Network Environment Learning) durch ständiges wechseln von Filter-Regeln. Sender und Empfänger müssen sich permanent anpassen. Bei statischem Warden wird nur einmal angepasst und danach ist kommunikation ungestört. Wegen dynamischen Warden müssen viel mehr Überprüfungs-Pakete verschickt werden. RAM/CPU-usage kann geringer sein, weil weniger Regeln gleichzeitig aktiv sind. Anzahl von aktiven Regeln und Regel-Wechsel-Intervall können Zufällig gewählt werden um in Durchschnitt noch bessere Ergebnisse zu erhalten.",
        "hint": ""
    },
    {
        "id": 253,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 254,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 255,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 256,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 257,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 258,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 259,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 260,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 261,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 262,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    },
    {
        "id": 263,
        "folder": "Information Hiding",
        "front": "",
        "back": "",
        "hint": ""
    }
]
